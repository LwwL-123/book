# Go内存分配

## 1. 概述

Go这门语言抛弃了C/C++中的开发者管理内存的方式：主动申请与主动释放，增加了逃逸分析和GC，将开发者从内存管理中释放出来，让开发者有更多的精力去关注软件设计，而不是底层的内存问题。这是Go语言成为高生产力语言的原因之一。

我们不需要精通内存的管理，因为它确实很复杂，但掌握内存的管理，可以让你写出更高质量的代码，另外，还能助你定位Bug。



![内存分配](https://picture-1258612855.cos.ap-shanghai.myqcloud.com/20220325172045.jpeg)

这幅图表达了计算机的存储体系，从上至下依次是：

- CPU寄存器
- Cache
- 内存
- 硬盘等辅助存储设备
- 鼠标等外接设备
- 从上至下，访问速度越来越慢，访问时间越来越长。

![内存分配](https://picture-1258612855.cos.ap-shanghai.myqcloud.com/20220325172048.png)

然而，CPU跟内存的速率也不是相同的，从上图可以看到，CPU的速率提高的很快（摩尔定律），然而内存速率增长的很慢，虽然CPU的速率现在增加的很慢了，但是内存的速率也没增加多少，速率差距很大，从1980年开始CPU和内存速率差距在不断拉大，为了弥补这2个硬件之间的速率差异，所以在CPU跟内存之间增加了比内存更快的Cache，Cache是内存数据的缓存，可以降低CPU访问内存的时间。

不要以为有了Cache就万事大吉了，CPU的速率还在不断增大，Cache也在不断改变，从最初的1级，到后来的2级，到当代的3级Cache，（有兴趣看cache历史）。



三级Cache分别是L1、L2、L3，它们的速率是三个不同的层级，L1速率最快，与CPU速率最接近，是RAM速率的100倍，L2速率就降到了RAM的25倍，L3的速率更靠近RAM的速率。

看到这了，你有没有Get到整个**存储体系的分层设计？自顶向下，速率越来越低，访问时间越来越长，从磁盘到CPU寄存器，上一层都可以看做是下一层的缓存。**

### 1.1  虚拟内存

虚拟内存是当代操作系统必备的一项重要功能了，它向进程屏蔽了底层了RAM和磁盘，并向进程提供了远超物理内存大小的内存空间。我们看一下虚拟内存的**分层设计**。

![内存分配](https://picture-1258612855.cos.ap-shanghai.myqcloud.com/20220325172053.png)



上图展示了某进程访问数据，当Cache没有命中的时候，访问虚拟内存获取数据的过程。

访问内存，实际访问的是虚拟内存，虚拟内存通过页表查看，当前要访问的虚拟内存地址，是否已经加载到了物理内存，如果已经在物理内存，则取物理内存数据，如果没有对应的物理内存，则从磁盘加载数据到物理内存，并把物理内存地址和虚拟内存地址更新到页表。

有没有Get到：**物理内存就是磁盘存储缓存层。**

另外，在没有虚拟内存的时代，物理内存对所有进程是共享的，多进程同时访问同一个物理内存存在并发访问问题。**引入虚拟内存后，每个进程都要各自的虚拟内存，内存的并发访问问题的粒度从多进程级别，可以降低到多线程级别。**



### 1.2  栈和堆

我们现在从虚拟内存，再进一层，看虚拟内存中的栈和堆，也就是进程对内存的管理。

![内存分配](https://picture-1258612855.cos.ap-shanghai.myqcloud.com/20220325172056.png)

上图展示了一个进程的虚拟内存划分，代码中使用的内存地址都是虚拟内存地址，而不是实际的物理内存地址。栈和堆只是虚拟内存上2块不同功能的内存区域：

- 栈在高地址，从高地址向低地址增长。
- 堆在低地址，从低地址向高地址增长。

**栈和堆相比有这么几个好处：**

1. 栈的内存管理简单，分配比堆上快。
2. 栈的内存不需要回收，而堆需要，无论是主动free，还是被动的垃圾回收，这都需要花费额外的CPU。
3. 栈上的内存有更好的局部性，堆上内存访问就不那么友好了，CPU访问的2块数据可能在不同的页上，CPU访问数据的时间可能就上去了。



### 1.3 堆内存管理

我们再进一层，当我们说内存管理的时候，主要是指堆内存的管理，因为栈的内存管理不需要程序去操心。这小节看下堆内存管理干的是啥，如上图所示主要是3部分：**分配内存块，回收内存块和组织内存块。**

在一个最简单的内存管理中，堆内存最初会是一个完整的大块，即未分配内存，当来申请的时候，就会从未分配内存，分割出一个小内存块(block)，然后用链表把所有内存块连接起来。需要一些信息描述每个内存块的基本信息，比如大小(size)、是否使用中(used)和下一个内存块的地址(next)，内存块实际数据存储在data中。

![内存分配](https://picture-1258612855.cos.ap-shanghai.myqcloud.com/20220325172101.png)

一个内存块包含了3类信息，如下图所示，元数据、用户数据和对齐字段，内存对齐是为了提高访问效率。下图申请5Byte内存的时候，就需要进行内存对齐。

![内存分配](https://picture-1258612855.cos.ap-shanghai.myqcloud.com/20220325172103.png)

释放内存实质是把使用的内存块从链表中取出来，然后标记为未使用，当分配内存块的时候，可以从未使用内存块中有先查找大小相近的内存块，如果找不到，再从未分配的内存中分配内存。

上面这个简单的设计中还没考虑内存碎片的问题，因为随着内存不断的申请和释放，内存上会存在大量的碎片，降低内存的使用率。为了解决内存碎片，可以将2个连续的未使用的内存块合并，减少碎片。

以上就是内存管理的基本思路，关于基本的内存管理，想了解更多，可以阅读这篇文章《Writing a Memory Allocator》，本节的3张图片也是来自这片文章。







![内存分配](https://picture-1258612855.cos.ap-shanghai.myqcloud.com/20220325172106.png)



## 小于32KB内存块的分配策略

当程序里发生了`32kb`以下的小块内存申请时，Go会从一个叫做的`mcache`的本地缓存给程序分配内存。这个本地缓存`mcache`持有一系列的大小为`32kb`的内存块，这样的一个内存块里叫做`mspan`，它是要给程序分配内存时的分配单元。

![image-20211222153644273](https://picture-1258612855.cos.ap-shanghai.myqcloud.com/20220325172110.png)

在Go的调度器模型里，每个线程`M`会绑定给一个处理器`P`，在单一粒度的时间里只能做多处理运行一个`goroutine`，每个`P`都会绑定一个上面说的本地缓存`mcache`。当需要进行内存分配时，当前运行的`goroutine`会从`mcache`中查找可用的`mspan`。从本地`mcache`里分配内存时不需要加锁，这种分配策略效率更高。

那么有人就会问了，有的变量很小就是数字，有的却是一个复杂的结构体，申请内存时都分给他们一个`mspan`这样的单元会不会产生浪费。其实`mcache`持有的这一系列的`mspan`并不都是统一大小的，而是按照大小，从8字节到32KB分了大概70类的`msapn`。

![image-20211222154003875](https://picture-1258612855.cos.ap-shanghai.myqcloud.com/20220325172114.png)

如果结构体的大小是32字节，正好32字节的这种`mspan`能满足需求，那么分配内存的时候就会给它分配一个32字节大小的`mspan`。

![image-20211222154151132](https://picture-1258612855.cos.ap-shanghai.myqcloud.com/20220325172116.png)



现在，我们可能会好奇，如果分配内存时`mcachce`里没有空闲的32字节的`mspan`了该怎么办？`Go`里还为每种类别的`mspan`维护着一个`mcentral`。

`mcentral`的作用是为所有`mcache`提供切分好的`mspan`资源。每个`central`会持有一种特定大小的全局`mspan`列表，包括已分配出去的和未分配出去的。每个`mcentral`对应一种`mspan`，当工作线程的`mcache`中没有合适（也就是特定大小的）的`mspan`时就会从`mcentral` 去获取。`mcentral`被所有的工作线程共同享有，存在多个`goroutine`竞争的情况，因此从`mcentral`获取资源时需要加锁。



`mcentral`的定义如下：

```
//runtime/mcentral.go

type mcentral struct {
    // 互斥锁
    lock mutex 
    
    // 规格
    sizeclass int32 
    
    // 尚有空闲object的mspan链表
    nonempty mSpanList 
    
    // 没有空闲object的mspan链表，或者是已被mcache取走的msapn链表
    empty mSpanList 
    
    // 已累计分配的对象个数
    nmalloc uint64 
}
```

`mcentral`里维护着两个双向链表，**nonempty**表示链表里还有空闲的`mspan`待分配。**empty**表示这条链表里的`mspan`都被分配了`object`。

![图片](https://picture-1258612855.cos.ap-shanghai.myqcloud.com/20220325172122)

如果上面我们那个程序申请内存的时候，`mcache`里已经没有合适的空闲`mspan`了，那么工作线程就会像下图这样去`mcentral`里去申请。

简单说下`mcache`从`mcentral`获取和归还`mspan`的流程：

- 获取 加锁；从`nonempty`链表找到一个可用的`mspan`；并将其从`nonempty`链表删除；将取出的`mspan`加入到`empty`链表；将`mspan`返回给工作线程；解锁。
- 归还 加锁；将`mspan`从`empty`链表删除；将`mspan`加入到`nonempty`链表；解锁。

![image-20211222154842718](https://picture-1258612855.cos.ap-shanghai.myqcloud.com/20220325172125.png)





当`mcentral`没有空闲的`mspan`时，会向`mheap`申请。而`mheap`没有资源时，会向操作系统申请新内存。`mheap`主要用于大对象的内存分配，以及管理未切割的`mspan`，用于给`mcentral`切割成小对象。

![图片](https://picture-1258612855.cos.ap-shanghai.myqcloud.com/20220325172128)

同时我们也看到，`mheap`中含有所有规格的`mcentral`，所以，当一个`mcache`从`mcentral`申请`mspan`时，只需要在独立的`mcentral`中使用锁，并不会影响申请其他规格的`mspan`。

上面说了每种尺寸的`mspan`都有一个全局的列表存放在`mcentral`里供所有线程使用，所有`mcentral`的集合则是存放于`mheap`中的。`mheap`里的`arena` 区域是真正的堆区，运行时会将 `8KB` 看做一页，这些内存页中存储了所有在堆上初始化的对象。运行时使用二维的 runtime.heapArena 数组管理所有的内存，每个 runtime.heapArena 都会管理 64MB 的内存。



![图片](https://picture-1258612855.cos.ap-shanghai.myqcloud.com/20220325172131)

如果 `arena` 区域没有足够的空间，会调用 runtime.mheap.sysAlloc 从操作系统中申请更多的内存。



## 大于32KB内存块的分配策略

Go没法使用工作线程的本地缓存`mcache`和全局中心缓存`mcentral`上管理超过32KB的内存分配，所以对于那些超过32KB的内存申请，会直接从堆上(`mheap`)上分配对应的数量的内存页（每页大小是8KB）给程序。

![image-20220105141746303](https://picture-1258612855.cos.ap-shanghai.myqcloud.com/20220325172134.png)



## 总结

我们把内存分配管理涉及的所有概念串起来，可以勾画出Go内存管理的一个全局视图：

![image-20220105141751765](https://picture-1258612855.cos.ap-shanghai.myqcloud.com/20220325172136.png)

总结起来关于Go内存分配管理的策略有如下几点：

- Go在程序启动时，会向操作系统申请一大块内存，由`mheap`结构全局管理。
- Go内存管理的基本单元是`mspan`，每种`mspan`可以分配特定大小的`object`。
- `本地缓存mcache`, `全局中心缓存mcentral`, `mheap`是`Go`内存管理的三大组件，
  - `mcache`管理线程在本地缓存的`mspan`；
  - `mcentral`管理全局的`mspan`供所有线程使用；
  - `mheap`管理`Go`的所有动态分配内存。
- 一般小对象通过`mspan`分配内存；大对象则直接由`mheap`分配内存。





本文节选自：wx网管叨bi叨

