# 抢占式调度

我们知道GC开始前要STW来进行开启写屏障等准备工作，所以STW就是要抢占所有的P，

而这段程序中，在双核cpu中，在go1.13以前，居然会死锁，也就是程序中有协程没被抢占，一直在执行，而STW一直在等待他让出

```go
func main() {
    go func() {
      i := 0
      for {
        println(i)
        i++
      }
    }
  
    for {

    }
}
```



## Go1.13

为什么：

STW要抢占所有的P，所以他会记录下自己要等待多少个P让出，当这个值减为0，目的就达到了。对于当前P，陷入系统调用的P，空闲状态的P，直接设置为GCstop状态即可。对于还有G正在运行的P，会将对应的g.stackguard0设置为一个特殊标识，告诉他GC正在等待让出，此外还会设置一个gcwaiting标识。

在goroutine创建的时候，栈的大小是固定2k的，为了防止出现栈溢出的情况，编译器会在有明显栈消耗的函数头部插入一些监测代码，但如果g.stackguard0被设置为特殊标识，就不会执行栈增长，而是会执行一次调度，在调度执行时，会检测gcwaiting标识，若发现gc在等待，则会让出当前P，设置为gcstop状态，也就是说，上面的代码空的for循环，没有执行函数，也就没有机会执行栈增长代码，也就不会开始调度了，所以他不知道gc在等待他让出。



## Go1.14

在1.13中，依赖栈增长检测代码的抢占方式，遇到没有函数调用，就会出现问题。

在1.14中，实现了基于信号的异步抢占方式。

首先如果g.stackguard0被设置为特殊标识，首先会判断硬件是否支持异步抢占，和用户是否允许开启异步抢占，如果都通过了就会吧p.preempt设置为true，并且交由preemptM来执行异步抢占，他的主要逻辑是通过runtime.signalM来向指定M发送sigPreempt信号，也就是通过操作系统中信号相关的系统调用，将指定信号发送给目标线程。



工作线程接收到信号以后，会调用对应信号的handler来处理，确定信号为sigPreempt信号以后，会首先确认runtime是否对指定的G进行异步抢占,也就是判断g.preempt和p.preempt是否为true，并且G还要在Grunning状态，然后还要确认在当前位置打断G是安全的，怎么确认呢，首先指定的G可以挂起并安全的扫描他的栈和寄存器，并且当前被打断的位置并没有打断写屏障，第二，指定的G还有足够的栈空间来注入一个异步函数调用，第三，可以安全的和runtime进行交互，主要是确认没有持有runtime相关的锁，继而不会再后面获得锁时造成死锁。

确认了抢占是安全的以后，就可以放心的通过pushcall，向G的上下文注入异步抢占函数调用了，这个异步抢占函数，是一个汇编函数，会把各个寄存器的值保存在栈上，然后就会进行调度

