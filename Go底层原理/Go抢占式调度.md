# 抢占式调度

我们知道GC开始前要STW来进行开启写屏障等准备工作，所以STW就是要抢占所有的P，

而这段程序中，在双核cpu中，在go1.13以前，居然会死锁，也就是程序中有协程没被抢占，一直在执行，而STW一直在等待他让出

```go
func main() {
    go func() {
      i := 0
      for {
        println(i)
        i++
      }
    }
  
    for {

    }
}
```



## Go1.13

为什么：

STW要抢占所有的P，所以他会记录下自己要等待多少个P让出，当这个值减为0，目的就达到了。对于当前P，陷入系统调用的P，空闲状态的P，直接这是为GCstop状态即可。对于还有G正在运行的P，会将对应的g.stackguard0设置为一个特殊标识，告诉他GC正在等待让出，此外还会设置一个gcwaiting标识。

在goroutine创建的时候，栈的大小是固定2k的，为了防止出现栈溢出的情况，编译器会在有明显栈消耗的函数头部插入一些监测代码，但如果g.stackguard0被设置为特殊标识，就不会执行栈增长，而是会执行一次调度，在调度执行时，会检测gcwaiting标识，若发现gc在等待，则会让出当前P，设置为gcstop状态，也就是说，上面的代码空的for循环，没有执行函数，也就没有机会执行栈增长代码，也就不会开始调度了，所以他不知道gc在等待他让出。



## Go1.14

在1.13中，依赖栈增长检测代码的抢占方式，遇到没有函数调用，就会出现问题。

在1.14中，实现了基于信号的异步抢占方式。

首先如果g.stackguard0被设置为特殊标识，首先会判断硬件是否支持异步抢占，和用户是否允许开启异步抢占，如果都通过了就会吧p.preempt设置为true，并且交由preemptM来执行异步抢占，他的主要逻辑是通过runtime.signalM来向指定M发送sigPreempt信号，也就是通过操作系统中信号相关的系统调用，将指定信号发送给目标线程。



工作线程接收到信号以后，会调用对应信号的handler来处理

