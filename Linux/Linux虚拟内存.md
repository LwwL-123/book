# Linux虚拟内存

## 1. 什么是虚拟内存

![img](https://gitee.com/lzw657434763/pictures/raw/master/Blog/20220124191152.jpg)

一开始都是单任务模式，一个进程直接操作物理内存，但后来发展到多任务模式，一个系统中，通常存在多个进程，如果直接操作物理内存，就很容易出现修改到其他进程的内存情况，甚至会覆盖操作系统所使用的的内存，所以出现了保护模式，即进程不直接使用物理内存，而是使用一个对应的虚拟内存，操作系统负责把虚拟内存映射到物理内存。

例如，在32位系统下，会把物理内存以`4k(2^12)`为一页，从虚拟内存到物理内存，是以页为单位映射的。然后操作系统会以链表的形式存储各个进程的控制信息，在windows系统中为pcb控制块，在linux系统中为一个task_struct结构体。每个进程的控制信息中，会有一个指针，指向当前进程的页表。



如果是一级页表,那么4G的内存，每个内存页的大小为4kb，则需要`4GB/4KB = 2^20` 1M个页表项，即页表（每个进程都有一个页表）占用4MB（`1M*4B=4MB`)的内存空间。一级页表管理地址空间如下

```
20 | 12 
```

32位内存，用前20位标识一个唯一的页表项，后12位则用来记录物理页的业内偏移地址，刚好2^12=4kb



但是通常linux为了节约内存，采取二级页表的模式也就是，每一个一级页表还对应一个二级页表，二级页表管理地址空间如下

```
10 | 10 | 12 
```

前十位用来标记1024个一级页表，中间十位用来标记二级页表，后12位一样是物理内存的页内偏移地址，一共用的空间为 `1k*4B+1k*1k*4B=4MB+4KB`，这样算下来其实还比一级页表多了4kb的空间，那么为什么会采用二级页表呢。

其实是因为，对于大多数进程来说，使用到的内存空间远为到达4GB，对于一级页表来说，必须要覆盖全部的虚拟地址空间，而对于二级页表来说，我们的二级页表无需创建，只在需要的时候在进行创建二级页表，这样就比只有一级页表必须要使用4M的空间，节省到了4K的空间加上要使用的二级页表，并且1024个第二级页表中，只会有很少的一部分在某一时刻正在使用，我们岂不是可以把二级页表都放在磁盘中，在需要时才调入到内存。

![image-20220121141027599](https://gitee.com/lzw657434763/pictures/raw/master/Blog/20220121141027.png)

除此之外，页表还有一个特殊功能，首先我们知道一个物理内存页是4kb，所以他一定是4kb的整数位，所以页表项对应的线性地址，低12位一定全是0，所以这12位我们可以用来存储其他的信息，比如内存页是否可读，可写，可执行等，其中最后一位用来标识该物理内存页是否已经映射。

这是因为进程向操作系统申请内存时，OS不会立马分配，只会先记录下来，等到进程访问这段内存空间时，才会映射到真正的物理内存，所以内存的虚拟地址空间，只是他可以使用的一个范围，只有真正被映射到物理内存，才算是能够合法使用的虚拟内存，而没有使用的部分，要使用就必须先进行映射。





#### 内存寻址和分配

而线性地址到物理地址的转换，会交给cpu当中的内存管理单元（MMU）来负责，当前页目录的物理地址，会被保存到一个特定的寄存器中，这样CPU就可以借助页目录和页表，把线性地址转换为物理地址了，此外由于频繁查页表会影响效率，CPU会把已经查询过的页表，缓存到快表(TLB)中，需要的时候，先去TLB查找，没有的话再去查页表，最后写入TLB

以上情况是页表内存在虚拟地址到物理地址的映射，而如果进程访问的物理地址还没有被分配，系统则会产生一个`缺页中断`，在中断处理时，系统切到内核态为进程虚拟地址分配物理地址。



![image-20220121142032129](https://gitee.com/lzw657434763/pictures/raw/master/Blog/20220121142032.png)

如果要切换到另一个进程，那么存储的寄存器页目录也会改变，之前的TLB缓存会失效，需要全部重新查询页表，这也是进程切换代价高的一个原因。如果cpu查页表时发现，对应的物理页还没有完成映射，就会发生缺页，那么就会去查询是否申请，如果已经申请，就实际分配物理页面并完成页表映射。



最后，虚拟内存其实会被分为内核空间和用户空间，所有用户会共享1G的内核空间，这也是进程间共享的一种方式。





## 2. 功能

虚拟内存不仅通过内存地址转换解决了多个进程访问内存冲突的问题，还带来更多的益处。

#### 进程内存管理

它有助于进程进行内存管理，主要体现在：

- 内存完整性：由于虚拟内存对进程的”欺骗”，每个进程都认为自己获取的内存是一块连续的地址。我们在编写应用程序时，就不用考虑大块地址的分配，总是认为系统有足够的大块内存即可。
- 安全：由于进程访问内存时，都要通过页表来寻址，操作系统在页表的各个项目上添加各种访问权限标识位，就可以实现内存的权限控制。

#### 数据共享

通过虚拟内存更容易实现内存和数据的共享。

在进程加载系统库时，总是先分配一块内存，将磁盘中的库文件加载到这块内存中，在直接使用物理内存时，由于物理内存地址唯一，即使系统发现同一个库在系统内加载了两次，但每个进程指定的加载内存不一样，系统也无能为力。

而在使用虚拟内存时，系统只需要将进程的虚拟内存地址指向库文件所在的物理内存地址即可。如上文图中所示，进程 P1 和 P2 的 B 地址都指向了物理地址 C。

而通过使用虚拟内存使用共享内存也很简单，系统只需要将各个进程的虚拟内存地址指向系统分配的共享内存地址即可。

#### SWAP

虚拟内存可以让帮进程”扩充”内存。

我们前文提到了虚拟内存通过缺页中断为进程分配物理内存，内存总是有限的，如果所有的物理内存都被占用了怎么办呢？

Linux 提出 SWAP 的概念，Linux 中可以使用 SWAP 分区，在分配物理内存，但可用内存不足时，将暂时不用的内存数据先放到磁盘上，让有需要的进程先使用，等进程再需要使用这些数据时，再将这些数据加载到内存中，通过这种”交换”技术，Linux 可以让进程使用更多的内存。



# linux虚拟内存空间布局

创建一个进程时，操作系统会为该进程分配一个 4GB 大小的虚拟 进程地址空间。 之所以是 4GB ，是因为在 32 位的操作系统中，一个指针长度是 4 字节 （32位）， 2的32次 方个地址寻址能力是从 0x00000000~0xFFFFFFFF 即为 4GB 大小的容量。

<img src="https://img-blog.csdnimg.cn/20201215154018754.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NDIzMTU0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom: 67%;" />



*1*）线性地址空间：是指*Linux*系统中从*0x00000000*到*0xFFFFFFFF*整个*4GB*虚拟存储空间。



*2*）内核空间：内核空间表示运行在处理器最高级别的超级用户模式（*supervisormode*）下的代码或数据，内核空间占用从*0xC0000000*到*0xFFFFFFFF*的*1GB*线性地址空间，内核线性地址空间由所有进程共享，但只有运行在内核态的进程才能访问，用户进程可以通过系统调用切换到内核态访问内核空间，进程运行在内核态时所产生的地址都属于内核空间。

![在这里插入图片描述](https://gitee.com/lzw657434763/pictures/raw/master/Blog/20211209153759.png)

通过这种方法，保证了进程在切换至内核态后能够快速的访问内核空间。



*3*）用户空间：用户空间占用从*0x00000000*到*0xBFFFFFFF*共*3GB*的线性地址空间，每个进程都有一个独立的*3GB*用户空间，所以用户空间由每个进程独有，但是内核线程没有用户空间，因为它不产生用户空间地址。另外子进程共享（继承）父进程的用户空间只是使用与父进程相同的用户线性地址到物理内存地址的映射关系，而不是共享父进程用户空间。运行在用户态和内核态的进程都可以访问用户空间。



# 面试题



### linux的虚拟内存是4G，而每个进程都有自己独立的4G内存空间，怎么理解？

 4G 指的是最大的寻址空间为4G

一个进程用到的虚拟地址是由内存区域表来管理的，实际用不了4G。而用到的内存区域，会通过页表映射到物理内存。所以每个进程都可以使用同样的虚拟内存地址而不冲突，因为它们的物理地址实际上是不同的。



### 内核用的是3G以上的1G虚拟内存地址，其中896M是直接映射到物理地址的，128M按需映射896M以上的所谓高位内存。各进程用的是同一个内核，什么叫“都运行内核”？

其实我们讲的每个进程都有4G虚拟地址空间，讲的都是“可以寻址”4G，意思是虚拟地址的0-3G对于一个进程的用户态和内核态来说是可以访问的，而3-4G是只有进程的内核态可以访问的。并不是说这个进程会用满这些空间。	



其次，所谓“独立拥有的虚拟地址”是指对于每一个进程，你可以访问自己的0-4G的虚拟地址。虚拟地址是“虚拟”的，需要转化为“真实”的物理地址。好比你有你的地址簿，我有我的地址簿。你和我的地址簿都有1、2、3、4页，但是每页里面的实际内容是不一样的，我的地址簿第1页写着3，你的地址簿第1页写着4，对你我自己来说都是用第1页（虚拟），实际上用的分别是第3、4页（物理），不冲突。



内核用的896M虚拟地址是直接映射的，意思是只要把虚拟地址减去一个偏移量（3G）就等于物理地址。同样，这里指的还是寻址，实际使用前还是要分配内存。而且896M只是个最大值。如果物理内存小，内核能使用（分配）的可用内存也小。



