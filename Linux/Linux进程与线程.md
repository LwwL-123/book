# 进程和线程

我们编写的代码只是一个存储在硬盘的静态文件，通过编译后就会生成二进制可执行文件，当我们运行这个可执行文件后，它会被装载到内存中，接着 CPU 会执行程序中的每一条指令，那么这个**运行中的程序，就被称为「进程」**。

在早期的操作系统中，只有进程，没有线程， 随着技术发展，在执行一些细小任务时，本身无需分配单独资源时，也只能创建进程来执行，但是进程切换开销很大，而且进程间通信共享数据也很麻烦，所以就提出了线程的概念。



同一个进程内多个线程之间共享相同的地址空间，就可以共享代码段、数据段、打开的文件等资源，但每个线程都有独立一套的寄存器和栈，可以看到线程执行时，CPU操作的是线程的栈帧，面向的是某个线程，所以才说线程是独立调度的最小单位，进程是资源分配的最小单位

<img src="https://gitee.com/lzw657434763/pictures/raw/master/Blog/20220124191833.png" alt="image-20220121153100602" style="zoom:50%;" />





在虚拟内存中，虚拟内存为了保障安全，把虚拟内存分为两部分，内核空间和用户空间，内核空间由所有用户共享，而用户空间不能直接访问内核空间。操作系统保存的进程控制信息PCB就保存在内核空间，PCB中保存有页表，进程ID，父进程ID，状态，句柄表等等，而相同状态的PCB会由链表的形式存储在内核中。

线程就是进程的执行体，他要有执行入口，通常是某个函数的指令入口，线程执行时，要使用操作系统从进程虚拟地址空间中分配的栈空间来存储数据，也就是线程栈。



在创建线程时，操作系统会在用户空间和内核空间分配两段栈，即用户栈和内核栈，线程切换到内核态执行时，会使用内核栈，为了是不允许用户代码对其进行修改以保证安全。操作系统会记录每个线程的控制信息，例如`执行入口，线程栈，线程ID等`，在Windows中线程控制信息对应TCB，可以在PCB中找到进程拥有的线程列表，同一个进程内的线程会共享进程地址空间和句柄表等资源。而在Linux中，只用了一个task_struct结构体，进程创建子进程时会指定他和自己使用同一套地址空间和句柄表的资源，用这种方法实现多线程的效果

<img src="https://gitee.com/lzw657434763/pictures/raw/master/Blog/20220124191833.png" alt="image-20220121175035090" style="zoom:50%;" />

### 1. 进程有哪些状态



<img src="https://gitee.com/lzw657434763/pictures/raw/master/Blog/20220121220648.png" alt="image-20220121220648358" style="zoom:67%;" />

假如进程死锁，那么死锁的进程，都会在阻塞状态，等待资源的释放

另外，还有一个状态叫**挂起状态**，它表示进程没有占有物理内存空间。这跟阻塞状态是不一样，阻塞状态是等待某个事件的返回。

由于虚拟内存管理原因，进程的所使用的空间可能并没有映射到物理内存，而是在硬盘上，这时进程就会出现挂起状态，另外调用 sleep 也会被挂起。

<img src="https://gitee.com/lzw657434763/pictures/raw/master/Blog/20220121220641.png" alt="image-20220121220641026" style="zoom:67%;" />

### 2. 进程控制块PCB

> PCB 具体包含什么信息呢？

**进程描述信息：**

- 进程标识符：标识各个进程，每个进程都有一个并且唯一的标识符；
- 用户标识符：进程归属的用户，用户标识符主要为共享和保护服务；

**进程控制和管理信息：**

- 进程当前状态，如 new、ready、running、waiting 或 blocked 等；
- 进程优先级：进程抢占 CPU 时的优先级；

**资源分配清单：**

- 有关内存地址空间或虚拟地址空间的信息，比如**页表的起始地址**，所打开文件的列表和所使用的 I/O 设备信息。

**CPU 相关信息：**

- CPU 中各个寄存器的值，当进程被切换时，CPU 的状态信息都会被保存在相应的 PCB 中，以便进程重新执行时，能从断点处继续执行。



PCB在内存中的存储方式是以链表方式存储：

![image-20220121220635140](https://gitee.com/lzw657434763/pictures/raw/master/Blog/20220124191835.png)

### 3. 用户态-》内核态

线程中发生函数调用就是在线程栈中分配函数调用栈，而虚拟内存分配，文件操作，网络读写等很多功能都是由操作系统来完成的，再向用户程序暴露接口。所以线程免不了要“系统调用”，CPU中会有一个特权标志，用于记录当前程序是执行在用户态还是内核态，只有标记为内核态才可以访问内核空间。如果线程处于用户态，就不能访问内核空间，所以系统调用发生时，就得切换到内核态，使用线程的内核栈，执行内核空间的系统函数

<img src="https://gitee.com/lzw657434763/pictures/raw/master/Blog/20220121192725.png" alt="image-20220121192724814" style="zoom:50%;" />

这就是从``用户态``切换到``内核态``。

最初系统调用是通过软中断触发的，就是通过指令模拟中断。在OS中，会有一张中断向量表，用来吧各个中断编号映射到相应的处理程序，例如在linux系统中，系统调用中断对应的编号为0x80，对应的系统程序，就是用来派发系统调用的。在硬件层面，CPU有一个中断控制器，负责接收中断信号，切换到内核态，保存用户态执行现场。一部分寄存器的值会通过硬件保存起来，还有一部分通用寄存器的值，会被压入内核栈中。等系统调用结束后，再利用之前保存的信息，恢复线程在用户态的执行现场，继续执行后面的指令，即完成的一次系统调用。

![image-20220121201347884](https://gitee.com/lzw657434763/pictures/raw/master/Blog/20220124191836.png)



### 4. 上下文切换

现代操作系统中，CPU的执行权被分为不同的时间片，只有获得CPU时间片的程序才能运行，由于时间片很短，所以用户感觉不到程序切换的过程。一个线程CPU时间用完时，CPU硬件时钟会触发一次时钟中断，对应的中断处理程序，会从已经就绪的线程中，挑选一个来执行

<img src="https://gitee.com/lzw657434763/pictures/raw/master/Blog/20220124191839.png" alt="image-20220121205405539" style="zoom: 67%;" />



如果现在要将线程A1切换到A2，而这两个线程同属于线程A，那么就只需要将线程A1的执行现场保存起来，后续再把指令指针，栈指针这些寄存器的值修改为线程A2的信息。当A1重新获得时间片时，会根据切换前保存在栈的信息，恢复到切换前的执行现场，继续完成他的任务

<img src="https://gitee.com/lzw657434763/pictures/raw/master/Blog/20220124191839.png" alt="image-20220121210340514" style="zoom:50%;" />

但如果现在线程A1要切换到另一个进程的线程B1，除了线程切换外，还要切换进程。首先CPU保存的页表需要切换到进程B，所以进程切换和线程切换的区别是，进程切换会导致地址空间等进程资源发生变化，还会导致TLB缓存失效，代价会更大



**进程的上下文切换不仅包含了虚拟内存、栈、全局变量等用户空间的资源，还包括了内核堆栈、寄存器等内核空间的资源**

**当两个线程是属于同一个进程，因为虚拟内存是共享的，所以在切换时，虚拟内存这些资源就保持不动，只需要切换线程的私有数据、寄存器等不共享的数据**

### 5. 软中断和硬中断

- 软中断是执行中断指令产生的，而硬中断是由外设引发的。
- 硬中断的中断号是由中断控制器提供的，软中断的中断号由指令直接指出，无需使用中断控制器。
- 硬中断是可屏蔽的，软中断不可屏蔽。

为了避免由于中断处理程序执行时间过长，而影响正常进程的调度，Linux 将中断处理程序分为上半部和下半部：

- 上半部，对应硬中断，由硬件触发中断，用来快速处理中断；
- 下半部，对应软中断，由内核触发中断，用来异步处理上半部未完成的工作；



软终端有：网络收发、定时、调度、RCU 锁等各种类型,可以通过查看 /proc/softirqs 来观察软中断的累计中断次数情况

### 6. 内核线程和用户线程(协程)

我们知道线程是进程中的执行体，拥有一个执行入口，以及从进程虚拟空间中分配的栈，包括用户栈和内核栈，操作系统会记录线程控制信息，而线程获得时间片以后才可以执行，CPU这里栈指针，指令指针等寄存器都要切换到对应的线程。

那么如果线程自己又创建几个执行体，给他们指定各自的执行入口，申请一些内存给他们作为执行栈，那么线程就可以按需调度这几个执行体了，为了实现这些执行体的切换，线程也需要记录他们的控制信息，其中包括id,栈的位置，执行入口地址，执行现场等等。

线程可以选择一个来执行，此时CPU中指令指针就会指向这个执行体的执行入口，栈帧和栈指针寄存器也会指向线程给他们分配的执行栈。要切换执行体时，要保存当前执行体中的执行现场，然后切换到另一个执行体，通过同样的方式，可以恢复到之前的执行体，这些由线程创建的执行体也就是所谓的协程，因为用户程序不能操作内核空间，所以只能给协程分配用户栈，而OS对协程一无所知，所以又叫做用户态线程

![image-20220122221620184](https://gitee.com/lzw657434763/pictures/raw/master/Blog/20220122221620.png)



### 7. 进程调度

进程都希望自己能够占用 CPU 进行工作，那么这涉及到前面说过的进程上下文切换。那到底什么时候调度进程，或以什么原则来调度进程呢？

#### 1. 调度分类

- **非抢占式调度算法**挑选一个进程，然后让该进程运行直到被阻塞，或者直到该进程退出，才会调用另外一个进程，也就是说不会理时钟中断这个事情。
- **抢占式调度算法**挑选一个进程，然后让该进程只运行某段时间，如果在该时段结束时，该进程仍然在运行时，则会把它挂起，接着调度程序从就绪队列挑选另外一个进程。这种抢占式调度处理，需要在时间间隔的末端发生**时钟中断**，以便把 CPU 控制返回给调度程序进行调度，也就是常说的**时间片机制**。



#### 2. 调度原则

*原则一*：如果运行的程序，发生了 I/O 事件的请求，那 CPU 使用率必然会很低，因为此时进程在阻塞等待硬盘的数据返回。这样的过程，势必会造成 CPU 突然的空闲。所以，**为了提高 CPU 利用率，在这种发送 I/O 事件致使 CPU 空闲的情况下，调度程序需要从就绪队列中选择一个进程来运行。**

*原则二*：有的程序执行某个任务花费的时间会比较长，如果这个程序一直占用着 CPU，会造成系统吞吐量（CPU 在单位时间内完成的进程数量）的降低。所以，**要提高系统的吞吐率，调度程序要权衡长任务和短任务进程的运行完成数量。**

*原则三*：从进程开始到结束的过程中，实际上是包含两个时间，分别是进程运行时间和进程等待时间，这两个时间总和就称为周转时间。进程的周转时间越小越好，**如果进程的等待时间很长而运行时间很短，那周转时间就很长，这不是我们所期望的，调度程序应该避免这种情况发生。**

*原则四*：处于就绪队列的进程，也不能等太久，当然希望这个等待的时间越短越好，这样可以使得进程更快的在 CPU 中执行。所以，**就绪队列中进程的等待时间也是调度程序所需要考虑的原则。**

*原则五*：对于鼠标、键盘这种交互式比较强的应用，我们当然希望它的响应时间越快越好，否则就会影响用户体验了。所以，**对于交互式比较强的应用，响应时间也是调度程序需要考虑的原则。**

![image-20220125123648750](https://gitee.com/lzw657434763/pictures/raw/master/Blog/20220125123648.png)

针对上面的五种调度原则，总结成如下：

- **CPU 利用率**：调度程序应确保 CPU 是始终匆忙的状态，这可提高 CPU 的利用率；
- **系统吞吐量**：吞吐量表示的是单位时间内 CPU 完成进程的数量，长作业的进程会占用较长的 CPU 资源，因此会降低吞吐量，相反，短作业的进程会提升系统吞吐量；
- **周转时间**：周转时间是进程运行和阻塞时间总和，一个进程的周转时间越小越好；
- **等待时间**：这个等待时间不是阻塞状态的时间，而是进程处于就绪队列的时间，等待的时间越长，用户越不满意；
- **响应时间**：用户提交请求到系统第一次产生响应所花费的时间，在交互式系统中，响应时间是衡量调度算法好坏的主要标准。

#### 3. 常见的调度算法

- 先来先服务调度算法
  - 非抢占式，**按照就绪队列选择最先进入队列的进程，直到运行结束**
- 最短作业优先调度算法
  - **优先选择运行时间最短的进程来运行**
- 高响应比优先调度算法
  - **每次进行进程调度时，先计算「响应比优先级」，然后把「响应比优先级」最高的进程投入运行**
- 时间片轮转调度算法
  - **每个进程被分配一个时间段，称为时间片（\*Quantum\*），即允许该进程在该时间段中运行。**
- 最高优先级调度算法
  - **从就绪队列中选择最高优先级的进程进行运行**
- 多级反馈队列调度算法
  - 「多级」表示有多个队列，每个队列优先级从高到低，同时优先级越高时间片越短。
  - 「反馈」表示如果有新的进程加入优先级高的队列时，立刻停止当前正在运行的进程，转而去运行优先级高的队列；



### 8. 进程通信

每个进程的用户地址空间都是独立的，一般而言是不能互相访问的，但内核空间是每个进程都共享的，所以进程之间要通信必须通过内核。

![image-20220125132221287](https://gitee.com/lzw657434763/pictures/raw/master/Blog/20220125132221.png)

- 管道：**半双工单向传输，效率低，不适合频繁交换数据**

  - 匿名管道：只能在父子进程间通信
  - 命名管道：提前创建了一个类型为管道的设备文件供进程使用，可以任意两个进程间通信

- 消息队列：**是保存在内核中的消息链表**

  - **消息队列通信过程中，存在用户态与内核态之间的数据拷贝开销**，因为进程写入数据到内核中的消息队列时，会发生从用户态拷贝数据到内核态的过程，同理另一进程读取内核中的消息数据时，会发生从内核态拷贝数据到用户态的过程。
  - **通信不及时，附件有大小限制**

- 共享内存：**可能产生冲突，可采用信号量的保护机制**

- 信号：**上面说的进程间通信，都是常规状态下的工作模式。对于异常情况下的工作模式，就需要用「信号」的方式来通知进程。**

  - 信号是进程间通信机制中**唯一的异步通信机制**，因为可以在任何时候发送信号给某一进程，一旦有信号产生，我们就有下面这几种，用户进程对信号的处理方式。

  - **1.执行默认操作**。Linux 对每种信号都规定了默认操作，例如，上面列表中的 SIGTERM 信号，就是终止进程的意思。Core 的意思是 Core Dump，也即终止进程后，通过 Core Dump 将当前进程的运行状态保存在文件里面，方便程序员事后进行分析问题在哪里。

    **2.捕捉信号**。我们可以为信号定义一个信号处理函数。当信号发生时，我们就执行相应的信号处理函数。

    **3.忽略信号**。当我们不希望处理某些信号的时候，就可以忽略该信号，不做任何处理。有两个信号是应用进程无法捕捉和忽略的，即 `SIGKILL` 和 `SEGSTOP`，它们用于在任何时候中断或结束某一进程。

- Socket：前面提到的管道、消息队列、共享内存、信号量和信号都是在同一台主机上进行进程间通信，那要想**跨网络与不同主机上的进程之间通信，就需要 Socket 通信了。**

#### 1. 匿名管道与命名管道

匿名管道的创建，需要通过下面这个系统调用：

```
int pipe(int fd[2])
```

这里表示创建一个匿名管道，并返回了两个描述符，一个是管道的读取端描述符 `fd[0]`，另一个是管道的写入端描述符 `fd[1]`。注意，这个匿名管道是特殊的文件，只存在于内存，不存于文件系统中。

<img src="https://gitee.com/lzw657434763/pictures/raw/master/Blog/20220125170158.png" alt="image-20220125170157991" style="zoom: 67%;" />

其实，**所谓的管道，就是内核里面的一串缓存**。从管道的一段写入的数据，实际上是缓存在内核中的，另一端读取，也就是从内核中读取这段数据。另外，管道传输的数据是无格式的流且大小受限。

如果要实现跨进程通信，我们可以使用 `fork` 创建子进程，**创建的子进程会复制父进程的文件描述符**，这样就做到了两个进程各有两个「 `fd[0]` 与 `fd[1]`」，两个进程就可以通过各自的 fd 写入和读取同一个管道文件实现跨进程通信了。

管道只能一端写入，另一端读出，所以上面这种模式容易造成混乱，因为父进程和子进程都可以同时写入，也都可以读出。那么，为了避免这种情况，通常的做法是：

- 父进程关闭读取的 fd[0]，只保留写入的 fd[1]；
- 子进程关闭写入的 fd[1]，只保留读取的 fd[0]；

<img src="https://gitee.com/lzw657434763/pictures/raw/master/Blog/20220125170820.png" alt="image-20220125170820171" style="zoom: 50%;" />

所以说如果需要双向通信，则应该创建两个管道。

到这里，我们仅仅解析了使用管道进行父进程与子进程之间的通信，但是在我们 shell 里面并不是这样的。

在 shell 里面执行 `A | B`命令的时候，A 进程和 B 进程都是 shell 创建出来的子进程，A 和 B 之间不存在父子关系，它俩的父进程都是 shell。

<img src="https://gitee.com/lzw657434763/pictures/raw/master/Blog/20220125170912.png" alt="image-20220125170912441" style="zoom:50%;" />

我们可以得知，**对于匿名管道，它的通信范围是存在父子关系的进程**。因为管道没有实体，也就是没有管道文件，只能通过 fork 来复制父进程 fd 文件描述符，来达到通信的目的。

另外，**对于命名管道，它可以在不相关的进程间也能相互通信**。因为命令管道，提前创建了一个类型为管道的设备文件，在进程里只要使用这个设备文件，就可以相互通信。

不管是匿名管道还是命名管道，进程写入的数据都是缓存在内核中，另一个进程读取数据时候自然也是从内核中获取，同时通信数据都遵循**先进先出**原则，不支持 lseek 之类的文件定位操作。



### 9. 僵尸进程和孤儿进程

`僵尸进程`（Z僵死状态（zombie））：当一个子进程结束运行（一般是调用exit、运行时发生致命错误或收到终止信号所导致）时，子进程的退出状态（返回值）会回报给操作系统，系统则以SIGCHLD信号将子进程被结束的事件告知父进程，此时子进程的进程控制块（PCB）仍驻留在内存中。一般来说，收到SIGCHLD后，父进程会使用wait系统调用以获取子进程的退出状态，然后内核就可以从内存中释放已结束的子进程的PCB；而如若父进程没有这么做的话，子进程的PCB就会一直驻留在内存中，也即成为僵尸进程



其实，僵尸进程是有危害的。进程的退出状态必须被维持下去，因为它要告诉关心它的进程（父进程），你交给我的任务，我办的怎么样了。可父进程如果一直不读取，那子进程就一直处于Z状态。维护退出状态本身就是要用数据维护，也属于进程基本信息，所以保存在task_struct(PCB)中，换句话说，当一个进程一直处于Z状态，那么它的PCB也就一直都要被维护。因为PCB本身就是一个结构体会占用空间，僵尸进程也就会造成资源浪费，所以我们应该避免僵尸进程的产生

想要解决僵尸进程也很简单，直接找到父进程杀掉，那么僵尸进程将会被init进程接管，并回收



`孤儿进程`：孤儿进程则是指当一个父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程。孤儿进程将被init进程(进程号为1)所收养，并由init进程对它们完成状态收集工作。

孤儿进程由于有init进程循环的wait()回收资源，因此并没有什么危害
