# 进程和线程

我们编写的代码只是一个存储在硬盘的静态文件，通过编译后就会生成二进制可执行文件，当我们运行这个可执行文件后，它会被装载到内存中，接着 CPU 会执行程序中的每一条指令，那么这个**运行中的程序，就被称为「进程」**。

在早期的操作系统中，只有进程，没有线程， 随着技术发展，在执行一些细小任务时，本身无需分配单独资源时，也只能创建进程来执行，但是进程切换开销很大，而且进程间通信共享数据也很麻烦，所以就提出了线程的概念。



同一个进程内多个线程之间共享相同的地址空间，就可以共享代码段、数据段、打开的文件等资源，但每个线程都有独立一套的寄存器和栈，可以看到线程执行时，CPU操作的是线程的栈帧，面向的是某个线程，所以才说线程是独立调度的最小单位，进程是资源分配的最小单位

<img src="https://gitee.com/lzw657434763/pictures/raw/master/Blog/20220124191833.png" alt="image-20220121153100602" style="zoom:50%;" />





在虚拟内存中，虚拟内存为了保障安全，把虚拟内存分为两部分，内核空间和用户空间，内核空间由所有用户共享，而用户空间不能直接访问内核空间。操作系统保存的进程控制信息PCB就保存在内核空间，PCB中保存有页表，进程ID，父进程ID，状态，句柄表等等，而相同状态的PCB会由链表的形式存储在内核中。

线程就是进程的执行体，他要有执行入口，通常是某个函数的指令入口，线程执行时，要使用操作系统从进程虚拟地址空间中分配的栈空间来存储数据，也就是线程栈。



在创建线程时，操作系统会在用户空间和内核空间分配两段栈，即用户栈和内核栈，线程切换到内核态执行时，会使用内核栈，为了是不允许用户代码对其进行修改以保证安全。操作系统会记录每个线程的控制信息，例如`执行入口，线程栈，线程ID等`，在Windows中线程控制信息对应TCB，可以在PCB中找到进程拥有的线程列表，同一个进程内的线程会共享进程地址空间和句柄表等资源。而在Linux中，只用了一个task_struct结构体，进程创建子进程时会指定他和自己使用同一套地址空间和句柄表的资源，用这种方法实现多线程的效果

<img src="https://gitee.com/lzw657434763/pictures/raw/master/Blog/20220124191833.png" alt="image-20220121175035090" style="zoom:50%;" />

### 进程有哪些状态



<img src="https://gitee.com/lzw657434763/pictures/raw/master/Blog/20220121220648.png" alt="image-20220121220648358" style="zoom:67%;" />

假如进程死锁，那么死锁的进程，都会在阻塞状态，等待资源的释放

另外，还有一个状态叫**挂起状态**，它表示进程没有占有物理内存空间。这跟阻塞状态是不一样，阻塞状态是等待某个事件的返回。

由于虚拟内存管理原因，进程的所使用的空间可能并没有映射到物理内存，而是在硬盘上，这时进程就会出现挂起状态，另外调用 sleep 也会被挂起。

<img src="https://gitee.com/lzw657434763/pictures/raw/master/Blog/20220121220641.png" alt="image-20220121220641026" style="zoom:67%;" />

### 进程控制块PCB

> PCB 具体包含什么信息呢？

**进程描述信息：**

- 进程标识符：标识各个进程，每个进程都有一个并且唯一的标识符；
- 用户标识符：进程归属的用户，用户标识符主要为共享和保护服务；

**进程控制和管理信息：**

- 进程当前状态，如 new、ready、running、waiting 或 blocked 等；
- 进程优先级：进程抢占 CPU 时的优先级；

**资源分配清单：**

- 有关内存地址空间或虚拟地址空间的信息，比如**页表的起始地址**，所打开文件的列表和所使用的 I/O 设备信息。

**CPU 相关信息：**

- CPU 中各个寄存器的值，当进程被切换时，CPU 的状态信息都会被保存在相应的 PCB 中，以便进程重新执行时，能从断点处继续执行。



PCB在内存中的存储方式是以链表方式存储：

![image-20220121220635140](https://gitee.com/lzw657434763/pictures/raw/master/Blog/20220124191835.png)

### 用户态-》内核态

线程中发生函数调用就是在线程栈中分配函数调用栈，而虚拟内存分配，文件操作，网络读写等很多功能都是由操作系统来完成的，再向用户程序暴露接口。所以线程免不了要“系统调用”，CPU中会有一个特权标志，用于记录当前程序是执行在用户态还是内核态，只有标记为内核态才可以访问内核空间。如果线程处于用户态，就不能访问内核空间，所以系统调用发生时，就得切换到内核态，使用线程的内核栈，执行内核空间的系统函数

<img src="https://gitee.com/lzw657434763/pictures/raw/master/Blog/20220121192725.png" alt="image-20220121192724814" style="zoom:50%;" />

这就是从``用户态``切换到``内核态``。

最初系统调用是通过软中断触发的，就是通过指令模拟中断。在OS中，会有一张中断向量表，用来吧各个中断编号映射到相应的处理程序，例如在linux系统中，系统调用中断对应的编号为0x80，对应的系统程序，就是用来派发系统调用的。在硬件层面，CPU有一个中断控制器，负责接收中断信号，切换到内核态，保存用户态执行现场。一部分寄存器的值会通过硬件保存起来，还有一部分通用寄存器的值，会被压入内核栈中。等系统调用结束后，再利用之前保存的信息，恢复线程在用户态的执行现场，继续执行后面的指令，即完成的一次系统调用。

![image-20220121201347884](https://gitee.com/lzw657434763/pictures/raw/master/Blog/20220124191836.png)



### 上下文切换

现代操作系统中，CPU的执行权被分为不同的时间片，只有获得CPU时间片的程序才能运行，由于时间片很短，所以用户感觉不到程序切换的过程。一个线程CPU时间用完时，CPU硬件时钟会触发一次时钟中断，对应的中断处理程序，会从已经就绪的线程中，挑选一个来执行

<img src="https://gitee.com/lzw657434763/pictures/raw/master/Blog/20220124191839.png" alt="image-20220121205405539" style="zoom: 67%;" />



如果现在要将线程A1切换到A2，而这两个线程同属于线程A，那么就只需要将线程A1的执行现场保存起来，后续再把指令指针，栈指针这些寄存器的值修改为线程A2的信息。当A1重新获得时间片时，会根据切换前保存在栈的信息，恢复到切换前的执行现场，继续完成他的任务

<img src="https://gitee.com/lzw657434763/pictures/raw/master/Blog/20220124191839.png" alt="image-20220121210340514" style="zoom:50%;" />

但如果现在线程A1要切换到另一个进程的线程B1，除了线程切换外，还要切换进程。首先CPU保存的页表需要切换到进程B，所以进程切换和线程切换的区别是，进程切换会导致地址空间等进程资源发生变化，还会导致TLB缓存失效，代价会更大



**进程的上下文切换不仅包含了虚拟内存、栈、全局变量等用户空间的资源，还包括了内核堆栈、寄存器等内核空间的资源**

**当两个线程是属于同一个进程，因为虚拟内存是共享的，所以在切换时，虚拟内存这些资源就保持不动，只需要切换线程的私有数据、寄存器等不共享的数据**

### 软中断和硬中断

- 软中断是执行中断指令产生的，而硬中断是由外设引发的。
- 硬中断的中断号是由中断控制器提供的，软中断的中断号由指令直接指出，无需使用中断控制器。
- 硬中断是可屏蔽的，软中断不可屏蔽。
- 硬中断处理程序要确保它能快速地完成任务，这样程序执行时才不会等待较长时间，称为上半部。
- 软中断处理硬中断未完成的工作，是一种推后执行的机制，属于下半部。

软终端有：时钟中断，系统中断



### 内核线程和用户线程(协程)

我们知道线程是进程中的执行体，拥有一个执行入口，以及从进程虚拟空间中分配的栈，包括用户栈和内核栈，操作系统会记录线程控制信息，而线程获得时间片以后才可以执行，CPU这里栈指针，指令指针等寄存器都要切换到对应的线程。

那么如果线程自己又创建几个执行体，给他们指定各自的执行入口，申请一些内存给他们作为执行栈，那么线程就可以按需调度这几个执行体了，为了实现这些执行体的切换，线程也需要记录他们的控制信息，其中包括id,栈的位置，执行入口地址，执行现场等等。

线程可以选择一个来执行，此时CPU中指令指针就会指向这个执行体的执行入口，栈帧和栈指针寄存器也会指向线程给他们分配的执行栈。要切换执行体时，要保存当前执行体中的执行现场，然后切换到另一个执行体，通过同样的方式，可以恢复到之前的执行体，这些由线程创建的执行体也就是所谓的协程，因为用户程序不能操作内核空间，所以只能给协程分配用户栈，而OS对协程一无所知，所以又叫做用户态线程

![image-20220122221620184](https://gitee.com/lzw657434763/pictures/raw/master/Blog/20220122221620.png)



### 调度

进程都希望自己能够占用 CPU 进行工作，那么这涉及到前面说过的进程上下文切换。那到底什么时候调度进程，或以什么原则来调度进程呢？

#### 1. 调度分类

- **非抢占式调度算法**挑选一个进程，然后让该进程运行直到被阻塞，或者直到该进程退出，才会调用另外一个进程，也就是说不会理时钟中断这个事情。
- **抢占式调度算法**挑选一个进程，然后让该进程只运行某段时间，如果在该时段结束时，该进程仍然在运行时，则会把它挂起，接着调度程序从就绪队列挑选另外一个进程。这种抢占式调度处理，需要在时间间隔的末端发生**时钟中断**，以便把 CPU 控制返回给调度程序进行调度，也就是常说的**时间片机制**。



#### 2. 调度原则

*原则一*：如果运行的程序，发生了 I/O 事件的请求，那 CPU 使用率必然会很低，因为此时进程在阻塞等待硬盘的数据返回。这样的过程，势必会造成 CPU 突然的空闲。所以，**为了提高 CPU 利用率，在这种发送 I/O 事件致使 CPU 空闲的情况下，调度程序需要从就绪队列中选择一个进程来运行。**

*原则二*：有的程序执行某个任务花费的时间会比较长，如果这个程序一直占用着 CPU，会造成系统吞吐量（CPU 在单位时间内完成的进程数量）的降低。所以，**要提高系统的吞吐率，调度程序要权衡长任务和短任务进程的运行完成数量。**

*原则三*：从进程开始到结束的过程中，实际上是包含两个时间，分别是进程运行时间和进程等待时间，这两个时间总和就称为周转时间。进程的周转时间越小越好，**如果进程的等待时间很长而运行时间很短，那周转时间就很长，这不是我们所期望的，调度程序应该避免这种情况发生。**

*原则四*：处于就绪队列的进程，也不能等太久，当然希望这个等待的时间越短越好，这样可以使得进程更快的在 CPU 中执行。所以，**就绪队列中进程的等待时间也是调度程序所需要考虑的原则。**

*原则五*：对于鼠标、键盘这种交互式比较强的应用，我们当然希望它的响应时间越快越好，否则就会影响用户体验了。所以，**对于交互式比较强的应用，响应时间也是调度程序需要考虑的原则。**

![图片](https://gitee.com/lzw657434763/pictures/raw/master/Blog/20220124221457)

针对上面的五种调度原则，总结成如下：

- **CPU 利用率**：调度程序应确保 CPU 是始终匆忙的状态，这可提高 CPU 的利用率；
- **系统吞吐量**：吞吐量表示的是单位时间内 CPU 完成进程的数量，长作业的进程会占用较长的 CPU 资源，因此会降低吞吐量，相反，短作业的进程会提升系统吞吐量；
- **周转时间**：周转时间是进程运行和阻塞时间总和，一个进程的周转时间越小越好；
- **等待时间**：这个等待时间不是阻塞状态的时间，而是进程处于就绪队列的时间，等待的时间越长，用户越不满意；
- **响应时间**：用户提交请求到系统第一次产生响应所花费的时间，在交互式系统中，响应时间是衡量调度算法好坏的主要标准。
