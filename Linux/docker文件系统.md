## docker文件系统

![Docker 容器文件系统](https://gitee.com/lzw657434763/pictures/raw/master/Blog/20211219193112.png)



上图从一个较为全面的角度阐述了 `Dockerfile` 、Docker 镜像与 Docker 容器三者的关系。

#### Dockerfile 体现

Docker 容器已经在运行，但是追本溯源，我们依然可以找到 `Dockerfile` 的影子。上图中，我们可以发现，Docker 容器依附 Docker 镜像，而 Docker 镜像的 `Dockerfile` 是这样的：

```dockerfile
FROM ubuntu:14.04
ADD run.sh /
VOLUME /data
CMD ["./run.sh"] 
```

我们可以看到，以上 `Dockerfile` 中的每一条命令，都在 Docker 镜像中以一个独立镜像层的形式存在。

#### Docker 镜像体现

毫无疑问，Docker 镜像是由 `Dockerfile` 构建而成，我们也可以看到图中下四层被标记为 Docker 镜像。作为 Docker 技术的核心，我们必须了解 Docker 如何构建镜像，以及 Docker 镜像构建之后的产物是什么。

初次接触 Docker，了解层级管理的 Docker 镜像之后，很容易就认为：每一层 Docker 镜像中都含有相应的文件系统文件。其实不然，以上 `Dockerfile` 中的四条命令，则是一个很好的佐证。

- `FROM ubuntu:14.04` ：设置基础镜像，此时会使用基础镜像 `ubuntu:14.04` 的所有镜像层，为简单起见，图中将其作为一个整体展示。
- `ADD run.sh /` ：将 `Dockerfile` 所在目录的文件 `run.sh` 加至镜像的根目录，此时新一层的镜像只有一项内容，即根目录下的 `run.sh` 。
- `VOLUME /data` ：设定镜像的 `VOLUME` ，此 `VOLUME` 在容器内部的路径为 `/data`。需要注意的是，此时并未在新一层的镜像中添加任何文件，但更新了镜像的 json 文件，以便通过此镜像启动容器时获取这方面的信息。
- `CMD ["./run.sh"]` ：设置镜像的默认执行入口，此命令同样不会在新建镜像中添加任何文件，仅仅在上一层镜像 json 文件的基础上更新新建镜像的 json 文件。



#### Docker 容器体现

涉及到 Docker 容器，便是动态的内容，一切似乎都有了生命。上文曾提及，Docker 容器的文件系统中不仅包含 Docker 镜像。此言不虚，图中的顶上两层，就是 Docker 为 Docker 容器新建的内容，而这两层恰恰不属于镜像范畴。

这两层分别为 Docker 容器的初始层（Init Layer）与可读写层（Read-Write Layer），初始层中大多是初始化容器环境时，与容器相关的环境信息，如容器主机名，主机 host 信息以及域名服务文件等。

再来看可读写层，这一层的作用非常大，Docker 的镜像层以及顶上的两层加起来，Docker 容器内的进程只对可读写层拥有写权限，其他层对进程而言都是只读的（Read-Only）。如 AUFS 等文件系统下，写下层镜像内容即会涉及 `COW` （Copy-on-Write）技术。另外，关于 `VOLUME` 以及容器的 `hosts`、`hostname` 、`resolv.conf` 文件等都会挂载到这里。需要额外注意的是，虽然 Docker 容器有能力在可读写层看到 `VOLUME` 以及 `hosts` 文件等内容，但那都仅仅是挂载点，真实内容位于宿主机上。

## 联合文件系统：aUFS

AUFS：全称 Union File System，又叫做 Another UnionFS,所谓的UnionFS,就是把不同物理位置的目录合并mount到同一个目录。而docker就是通过这个特性实现了镜像层的重叠，容器层的存储和显示层的展示。

aUFS的工作原理


![image-20211219190937070](https://gitee.com/lzw657434763/pictures/raw/master/Blog/20211219190944.png)

可以看到，假设我们存在2个目录X,Y，分别有A，B文件，那么aUFS的作用就是将这两个目录合并，并且重新挂载的Z上,这样在Z目录上就可以同时看到A和B文件。这就是联合文件系统，目的就是**将多个文件联合在一起成为一个统一的视图**。

![image-20211219191347601](https://gitee.com/lzw657434763/pictures/raw/master/Blog/20211219191347.png)

如上图，我们在Z目录中删除B文件，同时，在A文件中增加一些内容，如Hello。此时可以发现，X内的A文件新增了Hello,并且新增了一条B被删除的记录，但是Y中的B并没有任何变化。这是aUFS的一个重要特性。在所有的联合起来的目录中，**只有第一个目录是有写的权限**，即我们不管如何的去对Z进行修改操作，都只能对第一个联合进来的X修改，对Y是没有权限修改的。

**但是如果我们在Z中对Y中的文件进行了修改，它虽然没有权限去修改Y目录中的文件，但是它会在第一层目录添加一个记录来记录更改内容。**

## aUFS用来做了什么

我们再来看一下这张图，我们通过`docker history + 镜像ID`来查看镜像的历史。
当镜像启动的时候，一个新的可写层会加载到镜像的顶部，这一层我们一般称为**容器层**，之下是镜像层。
**容器层可以读写，容器所有发生文件变更都发生在这一层，而镜像层是read-only只读**。

![image-20211219192008852](https://gitee.com/lzw657434763/pictures/raw/master/Blog/20211219192008.png)

根据aUFS的定义，容器的文件系统就是由下面的15个只读镜像层和1个可写的容器层通过aUFS mount出来的。

到这里，就能和前面的aUFS联系起来了，**X就是容器层，可修改，可记录，Y就是镜像层，不可更改，只读，而Z就是我们进入联合起来的视图层**。

![image-20211219192513505](https://gitee.com/lzw657434763/pictures/raw/master/Blog/20211219192513.png)



## Docker的分层镜像

了解了aUFS之后，再来看一下docker的分层镜像。

![在这里插入图片描述](https://gitee.com/lzw657434763/pictures/raw/master/Blog/20211219192545.png)

我们通过对容器层A的修改重新构建了一层镜像，此时的镜像由原来的Y和X共同构成。
当我们运行这个新的镜像的时候，就创建出了一个新的容器P,而这个新创建的容器层P会继续接受视图层的更改请求。

可以看到X只是针对Y作出更改，而P只是针对重叠后的X做出更改，这种上层镜像只记录对下层镜像更改的方式，就是docker的分层镜像系统。



**问：启动docker的时候，对硬盘使用只读，意义在于什么？**

答：一个image可以启动多个container，这时候会有一个问题，如果每个container对大家共有的部分都有可写的权限，就会出问题。所以docker启动的时候会加载镜像的文件系统那层是只读的，然后每个contianer 获取自己的可读写的层，如果container要修改只读层的文件，那么该文件就会从只读层提取到读写层。只读层的文件就被读写层的文件覆盖了，但只读层的那个文件依然存在 这个就实现了文件系统上的隔离。



