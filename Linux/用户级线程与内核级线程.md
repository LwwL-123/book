# 用户级线程 与内核级线程



## **内核级线程** **(Kernel Supported threads** **—** **KST)** 

对于一切的进程，无论是系统进程还是用户进程，进程的创建和撤销，以及I/O操作都是利用系统调用进入到内核，由内核处理完成，所以说在KST下， 所有进程都是在操作系统内核的支持下运行的，是与内核紧密相关的。内核空间实现还为每个内核支持线程设置了一个线程控制快，内核是根据该控制快而感知某个 线程是否存在，并加以控制。

优点：

1. 在多处理器上，内核可以调用同一进程中的多个线程同时工作；

2. 如果一个进程中的一个线程阻塞了，其他线程仍然可以得到运行；

缺点：对于用户线程的切换代价太大，在同一个线程中，从一个线程切换到另一个线程时，需要从用户态，进入到内核态并且由内核切换。因为线程调度和管理在内核实现。

![img](https://gitee.com/lzw657434763/pictures/raw/master/Blog/20211130154848.jpg)

内核级线程驻留在内核空间，它们是内核对象。有了内核线程，每个用户线程被映射或绑定到一个内核线程。用户线程在其生命期内都会绑定到该内核线程。一旦用户线程终止，两个线程都将离开系统。这被称作"一对一"线程映射，如图所示。操作系统调度器管理、调度并分派这些线程。运行时库为每个用户级 线程请求一个内核级线程。操作系统的内存管理和调度子系统必须要考虑到数量巨大的用户级线程。您必须了解每个进程允许的线程的最大数目是多少。操作系统为 每个线程创建上下文。进程的每个线程在资源可用时都可以被指派到处理器内核。 

 

## **用户级线程** **(UserLevel Threads**    **—** **ULT)**

用户进程ULT仅存在于用户空间中。对于这种线程的创建、撤销、线程之间的同步和通信等功能，都无需系统调用来实现。对于同一进程的线程之间切换仍然是不需要内核支持的。所以，内核也会是完全不会知道用户级线程的存在。

但是有一点必须注意：设置了用户级线程的系统，其调度是以进程为单位进行的。

优点：

1. 线程切换不需要转换到内核空间，节省了宝贵的内核空间；

2. 调度算法可以是进程专用，由用户程序进行指定；

3. 用户级线程实现和操作系统无关；

缺点:

1. 系统调用阻塞，同一进程中一个线程阻塞和整个进程都阻塞了。

2. 一个进程只能在一个cpu上获得执行。

![img](https://gitee.com/lzw657434763/pictures/raw/master/Blog/20211130155624.jpg)

用户级线程驻留在用户空间或模式。运行时库管理这些线程，它也位于用户空间。它们对于操作系统是不可见的，因此无法被调度到处理器内核。每个线程并不具有 自身的线程上下文。因此，就线程的同时执行而言，任意给定时刻每个进程只能够有一个线程在运行，而且只有一个处理器内核会被分配给该进程。对于一个进程，可能有成千上万个用户级线程，但是它们对系统资源没有影响。运行时库调度并分派这些线程。如同在图中看到的那样，库调度器从进程的多个线程中 选择一个线程，然后该线程和该进程允许的一个内核线程关联起来。内核线程将被操作系统调度器指派到处理器内核。用户级线程是一种"多对一"的线程映射。

 

## **混合方式**

在很多的操作系统中ULT和KLT进行组合，整合了ULT和KLT的优点。

![img](https://gitee.com/lzw657434763/pictures/raw/master/Blog/20211130155811.jpg)

混合线程实现是用户线程和内核线程的交叉，使得库和操作系统都可以管理线程。用户线程由运行时库调度器管理，内核线程由操作系统调度器管理。在这种实现 中，进程有着自己的内核线程池。可运行的用户线程由运行时库分派并标记为准备好执行的可用线程。操作系统选择用户线程并将它映射到线程池中的可用内核线 程。多个用户线程可以分配给相同的内核线程。在图中，进程A在它的线程池中有两个内核线程，而进程B有3个内核线程。进程A的用户线程2和3 被映射到内核线程(2)。进程B有5个线程，用户线程1和2映射到同一个内核线程(3)，用户线程4和5映射到内核同一个内核线程(5)。当创建新的用户 线程时，只需要简单地将它映射到线程池中现有的一个内核线程即可。这种实现使用了"多对多"线程映射。该方法中尽量使用多对一映射。很多用户线程将会映射 到一个内核线程，就像您在前面的示例中所看到的。因此，对内核线程的请求将会少于用户线程的数目。



==内核线程池不会被销毁和重建，这些线程总是位于系统中。它们会在必要时分配给不同的用户级线程，而不是当创建新的用户级线程时就创建一个新的内核线程，而 纯内核级线程被创建时，就会创建一个新的内核线程。只对池中的每个线程创建上下文。有了内核线程和混合线程，操作系统分配一组处理器内核，进程的线程可以 在这些处理器内核之上运行。线程只能在为它们所属线程指派的处理器内核上运行。==



# **线程上下文**

操作系统管理很多进程的执行。有些进程是来自各种程序、系统和应用程序的单独进程，而某些进程来自被分解为很多进程的应用或程序。当一个进程从内核 中移出，另一个进程成为活动的，这些进程之间便发生了上下文切换。操作系统必须记录重启进程和启动新进程使之活动所需要的所有信息。这些信息被称作上下 文，它描述了进程的现有状态。当进程成为活动的，它可以继续从被抢占的位置开始执行。进程的上下文信息包括：

- 进程id
- 指向可执行文件的指针
- 栈
- 静态和动态分配的变量的内存
- 处理器寄存器



​	进程上下文的多数信息都与地址空间的描述有关。进程的上下文使用很多系统资源，而且会花费一些时间来从一个进程的上下文切换到另一个进程的上下文。 线程也有上下文。当线程被抢占时，就会发生线程之间的上下文切换。如果线程属于相同的进程，它们共享相同的地址空间，因为线程包含在它们所属于的进程的地址空间内。这样，进程需要恢复的多数信息对于线程而言是不需要的。尽管进程和它的线程共享了很多内容，但最为重要的是其地址空间和资源，有些信息对于线程而言是本地且唯一的，而线程的其他方面包含在进程的各个段的内部。



| 上下文内容                             | 进  程 | 线  程 |
| -------------------------------------- | ------ | ------ |
| 指向可执行文件的指针                   | x      |        |
| 栈                                     | x      | x      |
| 内存(数据段和堆)                       | x      |        |
| 状态                                   | x      | x      |
| 优先级                                 | x      | x      |
| 程序I/O的状态                          | x      |        |
| 授予权限                               | x      |        |
| 调度信息                               | x      |        |
| 审计信息                               | x      |        |
| 有关资源的信息● 文件描述符● 读/写指针  | x      |        |
| 有关事件和信号的信息                   | x      |        |
| 寄存器组● 栈指针● 指令计数器● 诸如此类 | x      | x      |


线程本地（且唯一）的信息包括线程id、处理器寄存器(当线程执行时寄存器的状态，包括程序计数器和栈指针)、线程状态及优先级、线程特定数据(thread-specific data，TSD)。

线程id是在创建线程时指定的。线程能够访问它所属进程的数据段，因此线程可以读写它所属进程的全局声明数据。进程中一个线程做出的任何改动都可以被进程中的所有线程以及主线程获得。在多数情况下，这要求某种类型的同步以防止无意的更新。线程的局部声明变量不应当被任何对等线程访问。 它们被放置到线程栈中，而且当线程完成时，它们便会被移走



# 如何避免频繁切换

用户态和内核态之间的切换有一定的开销，如果频繁发生切换势必会带来很大的开销，所以要想尽一切办法来减少切换。这也是面试常考的问题。

**减少线程切换**

因为线程的切换会导致用户态和内核态之间的切换，所以减少线程切换也会减少用户态和内核态之间的切换。那么如何减少线程切换呢？

- 无锁并发编程。多线程竞争锁时，加锁、释放锁会导致比较多的上下文切换。（使用Mutex Lock需要将当前线程挂起并从用户态切换到内核态来执行）
- CAS算法。使用CAS避免加锁，避免阻塞线程
- 使用最少的线程。避免创建不需要的线程
- 协程。在单线程里实现多任务的调度，并在单线程里维持多个任务间的切换
  