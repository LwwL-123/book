# P2P网路



# 1.分布式hash表 DHT

关于分布式多节点情景下数据如何布局，主要有两种思路

- **查表式**
  - 维护**全局统一的映射表**，需要访问数据时，先查询该表定位数据所在节点
  - 需要一个中心服务器维护全局的映射表信息，这可能成为系统的瓶颈；
- **计算式**
  - 无需维护该映射表，需要访问数据时，通过**一定规则**计算出数据所在位置
  - 主要问题在于存储节点的变更可能带来大量的数据迁移，增加系统复杂度。

`分布式Hash就是一种典型的计算式数据布局算法`



**分布式哈希表（distributed hash table，缩写DHT）**是分布式计算系统中的一类，用来将一个键（key）的集合分散到所有在分布式系统中的节点。这里的节点类似哈希表中的存储位置。分布式哈希表通常是为了拥有大量节点的系统，而且系统的节点常常会加入或离开。

其主要的动机是为了开发点对点系统。



*算法过程：*

DHT算法大致可以描述为以下两个子算法：

- 建立节点的位置算法
- 确定查询节点位置算法
- 确定存储对象的位置算法 => 提供服务



![ZTQGjf](https://gitee.com/lzw657434763/pictures/raw/master/Blog/20211013163746.png)

> **注意：这里的Ring结构只是举个例子，并不是所有的DHT都使用此结构**

所有的分布式节点都遵循这样的一套规则进行数据的存储与查询，整体向外提供高容灾性的服务。



*特性：*

分布式Hash表本质上强调以下特性：

- **离散性**：构成系统的节点并没有任何中央式的协调机制
- **伸缩性**：即使有成千上万个节点，系统仍然应该十分有效率
- **容错性**：即使节点不断地加入、离开或是停止工作，系统仍然必须达到一定的可靠度



# 2. Kademlia算法

```
Kademlia（简称kad）是一种通过 DHT 的协议算法，它是由Petar和David在2002年为P2P网络而设计的。Kademlia规定了网络的结构，也规定了通过节点查询进行信息交换的方式。
Kademlia网络节点之间使用UDP进行通讯。参与通讯的所有节点形成一张虚拟网（或者叫做覆盖网）。这些节点通过一组数字（或称为节点ID）来进行身份标识。节点ID不仅可以用来做身份标识，还可以用来进行值定位（值通常是文件的散列或者关键词）。

当我们在网络中搜索某些值（即通常搜索存储文件散列或关键词的节点）的时候，Kademlia算法需要知道与这些值相关的键，然后逐步在网络中开始搜索。每一步都会找到一些节点，这些节点的ID与键更为接近，如果有节点直接返回搜索的值或者再也无法找到与键更为接近的节点ID的时候搜索便会停止
```



`映射规则 / 节点位置计算方法`：

Kad使用160位的Hash算法，完整的Key有160二进制位，所以最多可以容纳2^160^个节点

Kad将所有的Key都映射到一个二叉树，每一个Key都是二叉树的叶子
将Key看作160位的二进制，二叉树的第n层就对应了第n位，可以按照左0右1的规则如下分割下去：

![k2P4PD](https://gitee.com/lzw657434763/pictures/raw/master/Blog/20211013164632.png)



分割完之后**叶子节点到根节点的路径**就对应于一个完整的Key，代表着该系统分布式的一个节点



`拆子树与K桶`：

- 拆子树

  - 每个节点按照自己的角度去拆分子树，从根节点开始看，如果其右子树不包含自己那么就将其左子树拆分出来，依此类推往下拆分直到只有自己
  - 因为Kad的Key一共是160位，其二叉树就是160层，那么对于一个节点来说最多拆分出来的子树有160个（每层拆一个）（当然实际情况节点数远小于2^160^
     个，节点拆分子树的个数也不会是160个）
  - 对于一个节点的n个拆分子树，如果都知道里面的一个节点，那么就可以利用这n个节点进行递归路由从而找到整个二叉树的所有节点(也即到达每一个节点)

  

- K桶（K-bucket）

  - 仅知道子树中的一个节点不够健壮(考虑到意外宕机等), 多个才安全
  - K就是指知道K个节点来保证健壮性(考虑实际情况K只是一个上限)，其K为一个系统级别的常量
  - K桶的概念其实就是路由表，节点需要知道n个子树就需要维护n个路由表/K桶，每个路由表/桶的上限大小是K
  - 选择K个节点：选择长时间在线的节点，如果当前K桶满了就将新的节点放入缓存，待有节点断连就将新节点更换之



Kad协议消息类型：

共四种：

- PING消息: 用来测试节点是否仍然在线。
- STORE消息: 在某个节点中存储一个键值对。
- FIND_NODE消息: 消息请求的接收者将返回自己桶中离请求键值最近的K个节点。
- FIND_VALUE消息: 与FIND_NODE一样，不过当请求的接收者存有请求者所请求的键的时候，它将返回相应键的值。
  每一个RPC消息中都包含一个发起者加入的随机值，这一点确保响应消息在收到的时候能够与前面发送的请求消息匹配



`定位最近节点`:

查询可以异步也可同步

1. 查询发起者节点从自己的K桶中筛选出离目标Id最近的一些节点，并发起异步查询请求
2. 被查询节点收到请求后，从自己的K桶中找出自己知道的与查询ID最近的若干个节点返回给发起者
3. 发起者收到后更新自己的结果列表，再次筛选出离目标最近的若干未请求过的节点重复步骤一
4. 直到找不到最近的未请求过的节点为止
5. 查询过程中未响应的节点会被立即排除；查询者需要最终获得的K个节点都是活动的
   

`定位资源`：

定位资源时，如果一个节点存有相应的资源的值的时候，它就返回该资源，搜索便结束了，除了该点以外，定位资源与定位离键最近的节点的过程相似。

考虑到节点未必都在线的情况，资源的值被存在多个节点上（节点中的K个），并且，为了提供冗余，还有可能在更多的节点上储存值。储存值的节点将定期搜索网络中与储存值所对应的键接近的K个节点并且把值复制到这些节点上，这些节点可作为那些下线的节点的补充。另外还有缓存技术。



`加入网络`：

1. 新节点A必须知道某个引导节点B，并把它加入到自己相应的K-桶中
2. 生成一个随机的节点ID,直到离开网络，该节点会一直使用该ID号
3. 向B（A目前知道的唯一节点）发起一个查询请求（FIND_NODE），请求的ID是自己（就是查询自己）
4. B收到该请求之后，会先把A的ID加入自己的相应的 K-桶中。并且根据 FIND_NODE 请求的约定，B会找到K个最接近 A 的节点，并返回给 A
5. A收到这K个节点的ID之后，把他们加入自己的 K-桶
6. 然后A会继续向刚刚拿到的这批节点(还未发送过请求的节点)发送查询请求（协议类型 FIND_NODE），如此往复，直至A建立了足够详细的路由表。
7. 这种“自我定位”将使得Kad的其他节点（收到请求的节点）能够使用A的ID填充他们的K-桶，同时也能够使用那些查询过程的中间节点来填充A的K-桶。这已过程既让A获得了详细的路由表，也让其它节点知道了A节点的加入



# 3. libp2p

Libp2p是Protocol Labs旗下的五个明星项目之一，五个项目彼此独立而又相互联系，旨在建立一个更安全、高效、开放的网络。

Libp2p是一个**模块化的网络栈**，通过将各种传输协议和P2P协议结合在一起，开发人员能够构建大型、健壮的P2P网络。

**Libp2p是IPFS的网络层,主要负责发现节点、连接节点、发现数据、传输数据**

**LibP2P实现了基于Kademlia-base的分布式Hash表**



## 3.1 传输

网络中不同电脑之间的数据传播很可能使用的就是TCP/IP协议, 当然要求快速但不可靠的服务可能会用到UDP

虽然TCP和UDP(连同IP)是目前最常用的协议，但它们绝不是唯一的选择。

备选方案存在于较低的级别(例如发送原始以太网数据包或蓝牙帧)和较高的级别(例如QUIC，它是在UDP之上分层的)。

在libp2p中，我们将这些围绕传输移动比特的基本协议称为基础协议，libp2p的核心需求之一是与传输无关。这意味着使用什么传输协议取决于开发人员，事实上一个应用程序可以同时支持许多不同的传输



传输具有两个核心的操作实现：监听和拨号

libp2p 实现中的每个传输都将共享相同的编程接口。

监听和拨号都需要知道如何联系他们，libp2p 使用一种称为“multiaddr多地址”的约定或对许多不同的寻址方案进行编码。

例子：`/ip4/7.7.7.7/tcp/6543` 其表示7.7.7.7属于IPv4协议, 6543属于tcp

包含PeerId的例子：/ip4/1.2.3.4/tcp/4321/p2p/QmcEPrat8ShnCph8WjkREzt5CPXF2RwhYxYBALDcLC1iV6

其添加了公钥的Hash唯一标识远程对等方

**当对等路由启动后，只需要使用PeerId即可拨打给对等方，而无需事先知道他们的传输地址**

## 3.2 NAT穿透

NAT(网络地址转换)简单来说就是一个局域网内的主机共享一个对外的公网IP，当需要数据传出时将公共IP替换成内部IP，当数据从另一端返回时，路由器将转换回内部IP

NAT的转出一般是透明的，转入则需要一些配置，指定到一些特定的端口中, 通常是通过将一个或多个 TCP 或 UDP 端口从公共 IP 映射到内部端口。

自动路由器配置：许多路由器支持端口转发的自动配置协议，最常见的是 UPnP 或者 nat-pmp。如果你的路由器支持这些协议之一，那么libp2p将会自动配置端口映射，无需其他操作。

当使用 IP 支持的传输时，libp2p 将尝试通过使用相同的端口进行拨号和侦听，使用名为的套接字选项 SO_REUSEPORT.

libp2p 的核心协议之一是identify protocol (识别协议)，这允许一个对等点向另一个点询问一些识别信息。当发送他们的公钥和一些其他有用的信息，被识别的对等方包括它为提出问题的对等方观察到的地址集。

虽然识别协议上面描述的让对等点相互通知他们观察到的网络地址，并非所有网络都允许在用于拨出的同一端口上进行传入连接。

其他对等点可以帮助我们观察我们的情况，这一次是通过尝试通过我们观察到的地址拨打我们的电话。如果这成功了，我们就可以依靠其他节点也可以拨打我们的电话，然后我们就可以开始宣传我们的收听地址了。

一个名为 AutoNAT 的 libp2p 协议允许对等方从提供 AutoNAT 服务的对等方请求回拨。

在某些情况下，对等方将无法以可公开访问的方式遍历其 NAT。

libp2p 提供了一个 电路中继协议 这允许对等点通过有用的中间对等点进行间接通信。


## 3.3 CIRCUIT RELAY 中继节点

电路继电器是一种 传输协议 通过第三方“中继”对等体在两个对等体之间路由流量。

中继连接是端到端加密的，这意味着充当中继的对等方无法读取或篡改流经连接的任何流量。

中继协议的一个重要方面是它不是“透明的”。换句话说，源和目的地都知道正在中继流量。这很有用，因为目的地可以看到用于打开连接的中继地址，并且可以潜在地使用它来构造返回源的路径。它也不是匿名的——所有参与者都使用他们的对等 ID 进行识别，包括中继节点。



假设我有一个 peer 的 peer id `QmAlice`。我想把我的地址给我的朋友`QmBob`，但我在一个不允许任何人直接给我拨号的 NAT 后面。

`p2p-circuit`我可以构造的最基本的地址如下所示：

```
/p2p-circuit/p2p/QmAlice
```

上面的地址很有趣，因为它不包含任何 [运输](https://docs.libp2p.io/concepts/transport/)我们要联系的对等点 ( `QmAlice`) 或将传送流量的中继对等点的地址。如果没有这些信息，对等方拨打我的唯一机会就是发现中继并希望他们与我建立联系。

更好的地址应该是`/p2p/QmRelay/p2p-circuit/p2p/QmAlice`. 这包括特定中继对等体的身份`QmRelay`。如果对等方已经知道如何打开与 的连接`QmRelay`，他们将能够联系到我们。

更好的是在地址中包含中继对等方的传输地址。假设我已经使用 peer id 建立了到特定中继的连接`QmRelay`。他们通过识别协议告诉我，他们正在侦听`55555`IPv4 地址端口上的TCP 连接`7.7.7.7`。我可以构建一个地址，描述通过该传输的特定中继到达我的路径：

```
/ip4/7.7.7.7/tcp/55555/p2p/QmRelay/p2p-circuit/p2p/QmAlice
```

`/p2p-circuit/`上述之前的所有内容都是中继对等体的地址，其中包括传输地址和它们的对等体 id `QmRelay`。After`/p2p-circuit/`是我在线路另一端的对等方的对等方 ID，`QmAlice`.

通过向我的朋友提供完整的中继路径`QmBob`，他们能够快速建立中继连接，而无需“四处询问”具有到`QmAlice`.



## 3.4 PROTOCOLS协议

## 什么是 libp2p 协议？

libp2p 协议具有以下关键特性：

#### 协议 ID

libp2p 协议具有唯一的字符串标识符，用于 [协议协商](https://docs.libp2p.io/concepts/protocols/#protocol-negotiation) 首次打开连接时的处理过程。

按照惯例，协议 ID 具有类似路径的结构，版本号作为最终组成部分：

```
/my-app/amazing-protocol/1.0.1
```

对协议的有线格式或语义进行重大更改应该会产生新的版本号。见[协议协商部分](https://docs.libp2p.io/concepts/protocols/#protocol-neotiation) 有关在拨号和收听过程中版本选择如何工作的更多信息。





## 3.5 PeerID

对等身份（通常写作`PeerId`）是对整个对等网络中特定对等的唯一引用。

除了充当每个对等点的唯一标识符外，PeerId 还是对等点与其公共加密密钥之间的可验证链接。

每个 libp2p peer 控制一个私钥，它对所有其他 peer 保密。每个私钥都有一个对应的公钥，与其他对等方共享。

公钥和私钥（或“密钥对”）一起允许对等方建立 安全通讯 通道相互。

从概念上讲，PeerId 是一个 加密散列对等方的公钥。当对等方建立安全通道时，散列可用于验证用于保护通道的公钥是否与用于识别对等方的公钥相同。

PeerIds 使用 多重散列 格式，它向散列本身添加一个小标头，用于标识用于生成它的散列算法。

PeerId被编码成Base-58然后表示为字符串（这与比特币类似）: QmYyQSo1c1Ym7orWxLYvCrM2EmxFTANf8wXmmE7DWjhx5N

```
PeerID生成的过程：创建私钥 => 导出公钥 => hash函数 => Base58编码
```



# 4. 总结



## 4.1 libp2p节点发现构建流程

![img](https://gitee.com/lzw657434763/pictures/raw/master/Blog/20211013182948.png)





## 4.2 libp2p中地址的转换关系

![libp2p_addr](https://gitee.com/lzw657434763/pictures/raw/master/Blog/20211013183055.png)

