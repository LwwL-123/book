# 以太坊签名：ECDSA、RLP、EIP155、EIP191、EIP712



我们把以太坊签名分为**对消息签名**与**对交易签名**，这两种签名都是基于**ECDSA算法与流程**，本章就让我们来搞清楚两种签名具体的内容。

![yuque_diagram.jpg](https://picture-1258612855.cos.ap-shanghai.myqcloud.com/202304121609540.jpg)

# 1. 签名概述

## 1.1 签名的作用或目的？

- **身份认证**：证明你拥有地址的私钥；
- **不可否认**：确认你的确发布过该消息；
- **完整性**：确保信息没有被篡改；

具体见维基百科：[wikipedia签名的性质](https://zh.wikipedia.org/wiki/數位簽章#操作)



## 1.2 什么是签名？

当我刚开始接触签名这个名词时，我也很困惑，此处的签名和现实世界中合同的签名有什么不同？当我签署一份租房合同，当我们租期到时，如果对屋内的物品所有损坏，房东可凭借这份合同上的内容对我进行索赔（扣押金），如果我进行抵赖，说我没签署过这份合同，那么房东可去司法机构进行签名**笔迹认证**。以太坊中的签名也是如此，在租房合同中签名是**笔迹**，在以太坊中的签名就是**一段数据**，这段数据的作用和我签署租房合同的签名笔迹没有任何不同，节点们（矿工们、验证者们）可以凭借这段数据进行**身份认证**，即证明这些消息就是我签署的（因为只有我拥有私钥），同时，我想抵赖也是不可能的，因为这段数据具备**不可否认性**，第三方也不可能对消息进行篡改，因为这段数据具备**完整性**。如果对上面阐述的内容暂时不理解也没关系，继续往下看，多看一些资料很快就会理解的。**此时我们只需记住，以太坊或者计算机中这个"签名"与现实世界中的向"合同上签名"是一个意义。**下面先概括一下以太坊的签名与验证过程：

- **签名过程**：ECDSA_正向算法（**消息** + **私钥** + 随机数）= 签名
- **验证过程**：ECDSA_反向算法（**消息** + **签名**）= 公钥

在以太坊、比特币中这个算法是经过二开的**ECDSA**（原始的ECDSA只有**r、s**组成，以太坊、比特币的ECDSA由**r、s、v**组成）。

# 2. 使用ECDSA签名并验证

## 2.1 什么是ECDSA

ECDSA可理解为以太坊、比特币对消息、交易进行签名与验证的算法与流程。在智能合约层面，我们不必多关注其算法的细节，只需理解其流程，看得懂已有项目代码，可以在项目写出对应功能代码即可。

## 2.2 流程

- **签名**即`正向算法（消息 + 私钥 + 随机数）= 签名`，其中**消息**是公开的，**私钥**是隐私的，经过ECDSA正向算法可得到**签名，即r、s、v**（不用纠结与r、s、v到底什么，只需要知道这就是签名即可）。
- **验证**即`反向算法（消息 + 签名）= 公钥`，其中**消息**是公开的，**签名**是公开的，经过ECDSA反向算法可得到**公钥**，然后对比**已公开的公钥。**

![image.png](https://picture-1258612855.cos.ap-shanghai.myqcloud.com/202304121613416.png)

## 2.3 关键词

**RLP**：一种序列化的方式，其与网络传输中json的序列化/反序列化有一些不同，RLP不仅兼顾网络传输，其编码特性更确保了**编码后的一致性**，因为每笔交易过程中要进行**Keccak256**，如果不能保证编码后的一致性，会导致其Hash值不同，那么验证者就无法验证交易是否由同一个人发出。

- 若对上面的阐述不理解，继续看下面的内容。
- 编码方式详情见[详解以太坊RLP编码](https://learnblockchain.cn/books/geth/part3/rlp.html)（不用过度研究）。

**Keccak256** ：以太坊的Hash算法，生成32个字节Hash值。



## 2.4 **签名过程**：签名交易流程

1. **构建原始交易对象**

- **nonce**: 记录发起交易的账户已执行交易总数。Nonce的值随着每个新交易的执行不断增加，这能让网络了解执行交易需要遵循的顺序，并且作为交易的重放保护。
- **gasPrice**:该交易每单位gas的价格，Gas价格目前以Gwei为单位（即10^9wei），其范围是大于0.1Gwei，可进行灵活设置。
- **gasLimit**:该交易支付的最高gas上限。该上限能确保在出现交易执行问题（比如陷入无限循环）之时，交易账户不会耗尽所有资金。一旦交易执行完毕，剩余所有gas会返还至交易账户。
- **to**：该交易被送往的地址（调用的合约地址或转账对方的账户地址）。
- **value**：交易发送的以太币总量。
- data：
  - 若该交易是以太币交易，则data为空；
  - 若是部署合约，则data为合约的bytecode；
  - 若是合约调用，则需要从合约ABI中获取函数签名，并取函数签名hash值前4字节与所有参数的编码方式值进行拼接而成，具体参见文章[Ethereum的合约ABI拓展](https://github.com/linjie-1/guigulive-operation/wiki/Ethereum的合约ABI拓展)
- **chainId**：防止跨链重放攻击。 ->EIP155

2. **签署交易**

签署交易可使用**MetaMask**和**ethers库。**

- **MetaMask**

前端：使用**MetaMask**进行签名为前端技术栈，目前比较流行为nextjs+ethers，我对前端不太了解，这里不做展开。

- **ethers库**

后端：使用**ethers库**可以进行交易的签名，详情见如下代码：

```js
const ethers = require("ethers")
require("dotenv").config()

async function main() {
    // 将RPC与私钥存储在环境变量中
    // RPC节点连接，直接用alchemy即可
    let provider = new ethers.providers.JsonRpcProvider(process.env.RPC_URL)
    // 新建钱包对象
    let wallet = new ethers.Wallet(process.env.PRIVATE_KEY, provider)
    // 返回这个地址已经发送过多少次交易
    const nonce = await wallet.getTransactionCount()
    // 构造raw TX
    tx = {
      nonce: nonce,
      gasPrice: 100000000000,
      gasLimit: 1000000,
      to: null,
      value: 0,
      data: "",
      chainId: 1, //也可以自动获取chainId = provider.getNetwork()
    }
    // 签名，其中过程见下面详述
    let resp = await wallet.signTransaction(tx)
  	console.log(resp)
    // 发送交易
    const sentTxResponse = await wallet.sendTransaction(tx);
}

main()
    .then(() => process.exit(0))
    .catch((error) => {
        console.error(error)
        process.exit(1)
    })


```

### 签署消息

ECDSA 签名由两个数字（整数）组成：`r` 和 `s`。以太坊还引入了额外的变量 `v`（恢复标识符）。签名可以表示成 `{r, s, v}`。

在创建签名时，你要先准备好一条待签署的消息，和用来签署该消息的私钥（`dₐ`）。简化后的签名流程如下：

1. 对待签署消息进行哈希计算，得到哈希值（`e`）。
2. 生成一个安全的随机数 `k`。
3. 将 `k` 乘以椭圆曲线的常量 `G`，来计算椭圆曲线上的点（x₁, y₁）。
4. 计算 `r = x₁ mod n`。如果 `r` 等于 0，请返回步骤 2 。
5. 计算 `s = k⁻¹(e + rdₐ) mod n`。如果 `s` 等于 0，请返回步骤 2。

在以太坊上，通常使用 `Keccak256("\x19Ethereum Signed Message:\n32" + Keccak256(message))`来计算哈希值。这样可以确保该签名不能在以太坊之外使用。

由于 `k` 是随机值，我们每次得到的签名都不一样。如果 `k` 的随机程度不够高，或者随机值被泄漏，就有可能使用两个不同的签名计算出私钥【“fault attack”】。但是，如果你在 [MyCrypto 内签署同一条消息](https://mycrypto.com/sign-and-verify-message/sign)，每次得到的输出值都相同，那么如何确保其安全性？这些确定性签名均采用 [RFC 6979 标准](https://tools.ietf.org/html/rfc6979)。该标准描述了如何基于私钥和消息（或哈希值）来生成安全的 `k` 值。

`{r, s, v}` 签名可以组成一个长达 65 字节的序列：`r` 有 32 个字节，`s` 有 32 个字节，`v` 有一个字节。如果我们将该签名编码成一个十六进制的字符串，我们最后会得到一个 130 个字符长的字符串。大多数钱包和界面都会使用这个字符串。以 MyCrypto 为例，一个完整的签名如下图所示：

```
{
  "address": "0x76e01859d6cf4a8637350bdb81e3cef71e29b7c2",
  "msg": "Hello world!",
  "sig": "0x21fbf0696d5e0aa2ef41a2b4ffb623bcaf070461d61cf7251c74161f82fec3a4370854bc0a34b3ab487c1bc021cd318c734c51ae29374f2beb0e6f2dd49b4bf41c",
  "version": "2"
}
```

在 MyCrypto 的 “验证消息（Verify Message）” 一页中，我们可以使用该签名，并看到该消息是由 `0x76e01859d6cf4a8637350bdb81e3cef71e29b7c2` 签署的。

MyCrypto 上的签名验证通过。点击[此处](https://mycrypto.com/sign-and-verify-message/verify)，即可体验。

你可能会问：为什么要将 `address`、`msg` 和 `version` 等其它信息也包括在内？不能只验证签名本身吗？好吧，不能。如果不保留其它信息，就好像签了一个合同，然后删除了合同里的所有信息，只留下当事人的签名。不同于交易签名（我们之后会作更深入解释），消息签名就只是签名而已（译者注：因此只有签名是没法验证的）。

为了验证消息，我们需要掌握原始消息、使用私钥签署消息的地址，以及 `{r, s, v}` 签名本身。版本号就是 MyCrypto 使用的某个版本号。旧版本的 MyCrypto 通常会加上消息的当前日期和时间，计算其哈希值，然后按照上述步骤签署该消息。后来又进行了更改，以符合 JSON-RPC 方法`personal_sign` 方法，因此需要指明版本号（“2”）。

简化后的公钥恢复流程如下：

- 计算消息的哈希值（`e`）。
- 计算椭圆曲线上的点 `R = (x₁, y₁)`，其中 x₁ 是 `r`（`v = 27`），或 `r + n`（`v = 28`）。
- 计算 `u₁ = -zr⁻¹ mod n` 和 `u₂ = sr⁻¹ mod n`。
- 计算点 `Qₐ = (xₐ, yₐ) = u₁ × G + u₂ × R`。

`Qₐ` 是地址用来签名的私钥所对应的公钥。我们可以通过公钥计算出一个地址，并检查该地址是否与已提供地址相符。如果相符，则签名有效。

### 恢复标识符（“v”）

`v` 是签名的最后一个字节，而且不是 27 (`0x1b`) 就是 28 (`0x1c`)。恢复标识符非常重要，因为我们使用的是椭圆曲线算法，仅凭`r` 和 `s` 可计算出曲线上的多个点，因此会恢复出两个不同的公钥（及其对应地址）。`v` 会告诉我们应该使用这些点中的哪一个。

在大多数实现中，[`v` 在内部只是 0 或 1](https://github.com/ethereum/go-ethereum/issues/19751#issuecomment-504900739)，而 27 是在签署比特币消息时加上的任意数。以太坊也接受了这一点。

从 [EIP-155](https://eips.ethereum.org/EIPS/eip-155) 开始，我们还使用链 ID 来计算 `v` 值。这可以防止跨链重放攻击：以太坊上签署的交易无法在以太坊经典上使用，反之亦然。目前，恢复标识符只用来签署交易而非消息。



### 签署交易

目前为止，我们主要讨论了针对消息的签名。就像消息一样，交易在发送前也需要签名。如果你使用 Ledger 和 Trezor 之类的硬件钱包，签名过程会在硬件内部发生。如果使用私钥（或 keysotre 文件、助记词），可以直接在 MyCrypto 上完成签名。签署交易所使用的方法与签署消息非常相似，只不过交易的编码方式略有不同。

要签署的交易先用 [RLP](https://eth.wiki/en/fundamentals/rlp) 编码方式编码，包含了所有交易参数（nonce、gas price、gas limit、to、value、data）和签名（v, r, s）。签过名的交易如下所示：

```
0xf86c0a8502540be400825208944bbeeb066ed09b7aed07bf39eee0460dfa261520880de0b6b3a7640000801ca0f3ae52c1ef3300f44df0bcfd1341c232ed6134672b16e35699ae3f5fe2493379a023d23d2955a239dd6f61c4e8b2678d174356ff424eac53da53e17706c43ef871
```

如果我们在 [MyCrypto 的已签名交易广播页面](https://mycrypto.com/pushTx)上输入该交易，我们就会看到所有交易参数：

![img](https://picture-1258612855.cos.ap-shanghai.myqcloud.com/202304121729879.jpg)

MyCrypto 的已签名交易广播页面上的交易参数概览

签过名的交易的第一组字节包含 RLP 编码后的交易参数，最后一组字节包含签名 `{r, s, v}`。我们可以通过以下方式对签名交易进行编码：

- 交易参数：`RLP(nonce, gasPrice, gasLimit, to, value, data, chainId, 0, 0)`。
- 使用 Keccak256 算法来计算经过 RLP 编码的未签署交易的哈希值。
- 按照上文讲述的步骤，通过 ECDSA 算法，使用私钥签署哈希值。
- 对已签名的交易进行编码：`RLP(nonce, gasPrice, gasLimit, to, value, data, v, r, s)`。

将经过 RLP 编码的交易数据解码后，我们又可以得到原始交易参数和签名。

请注意，链 ID 是被编码到签名的 `v` 参数中的，因此我们不会将链 ID 本身包含在最终的签名交易数据中。我们也不会提供任何发送方地址，因为地址可以通过签名恢复。这就是以太坊网络内部用来验证交易的方式。

## 签名消息的标准化

关于如何为签名消息定义标准结构，人们提出了很多种提议。目前为止，还没有一个提议最终确定下来。[最初由 Geth 实现的](https://github.com/ethereum/go-ethereum/pull/2940) `personal_sign` 格式依然是最常见的。尽管如此，有一些提议非常有趣。

我先来简单介绍下目前创建签名所采用的方式：

```
"\x19Ethereum Signed Message:\n" + length(message) + message
```

消息通常会预先进行哈希计算，因此长度会固定在 32 个字节：

```
"\x19Ethereum Signed Message:\n32" + Keccak256(message)
```

完整的消息（包括前缀）会再经历一次哈希计算，然后用私钥对哈希值签名。这种方式适用于所有权证明，但是在其它情况下可能会出现问题。例如，如果用户 `A` 签署了一个消息并将其发送给合约 `x`，用户 `B` 可以复制这个已签署消息并发送给合约 `Y`。这就叫[重放攻击](https://en.wikipedia.org/wiki/Replay_attack)。有一些提案旨在解决这一问题，如 EIP 191 和 EIP 721。