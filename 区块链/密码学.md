# 密码学

## 1. 哈希函数

在计算机编程中，哈希函数将文本(或其他数据)映射为整数。通常不同的输入映射到不同的输出，但有时可能会发生冲突(相同输出的不同输入)。

加密哈希函数将文本或二进制数据转换为固定长度的哈希值，并且已知具有抗碰撞性和不可逆性。密码杂凑函数的例子是 SHA3-256:

```
SHA3-256("hello") = "3338be694f50c5f338814986cdf0686453a888b84f424d792af4b9202398f392"
```

哈希函数在设计上是不可逆的，这意味着没有快速的算法从哈希值恢复输入消息。



### 1.1 **Secure Hash Functions** 安全哈希函数

现代加密哈希算法(如 SHA-3和 BLAKE2)被认为对大多数应用程序足够安全。

- SHA-2被开发人员和密码学中广泛使用，并且被认为在密码学上足够强大，可以用于现代商业应用程序。
- SHA-256广泛用于比特币区块链，例如用于识别交易散列和矿工进行的工作证明挖掘。

根据设计，散列输出中的更多位可望实现更强的安全性和更高的冲突抵抗力(除了一些例外情况)。一般来说，128位散列函数比256位散列函数弱，而256位散列函数比512位散列函数弱。因此，SHA-512比 SHA-256更强，所以我们可以预期，SHA-512比 SHA-256更不可能实际发现碰撞。

- SHA-3函数族是基于密码学概念的“ Keccak”散列族的代表，与 SHA-2不同，SHA-3系列的加密散列函数不容易受到长度延伸攻击长度延伸攻击



## 2.地址

- **P2PKH: "Pay To Public Key Hash"**，这个就是向公钥的哈希支付

这是最常用的交易方式。即，当你想要去花存在一个地址的比特币的时候，你需要提供

1. 签名
2. 公钥

这笔转账的验证者会利用你提供的公钥验证这个哈希和签名，来确认这笔交易合法。这个方法可以很好的保护好你的public key（在你花钱之前你的公钥不会被暴露）。

- **P2PK: "Pay To Public Key" 向公钥支付**

这个就很直接了，和就是P2PKH的简化版，也就是直接把public key作为地址来接受转账。

- **P2SH: "Pay To Script Hash" 向脚本地址支付。**

首先，来明确我们为什么需要这个。我们来看看P2PKH，“这笔转账的验证者会利用你提供的公钥验证这个哈希和签名，来确认这笔交易合法。”这句话其实是一个验证方法，可以理解为一个规则，这个规则是，当public key的hash被验证成功时，这笔钱就可以被动用。

但是当现实生活中遇到更多的使用场景，比如，如果需要两个人同时允许才能动用这个地址的钱，怎么办呢？现在“这笔转账的验证者会利用你提供的公钥验证这个哈希和签名，来确认这笔交易合法。”的单一触发条件就不够了。我可以自定义这个条件么？这个条件其实就是脚本。

用代码看比较清楚：

```js
const { address } = bitcoinLib.payments.p2sh({ // 生成一个向脚本地址支付的transaction
  redeem: bitcoinLib.payments.p2ms({ // 设置 multi-signature的赎回条件
    m: num, 
    pubkeys: publicKeysHex
  })
});
```

通过这个script hash，我们就可以支持更复杂的钱包类型了。



## 3.数字签名

- 数字签名的核心是私钥加签、公钥验签；加签是利用私钥对数据进行签名生成签名值，验签是从签名中恢复公钥的过程。

![img](https://img-blog.csdnimg.cn/img_convert/fc38caaf9c411a8e0aa122fc916a7e94.png)

- 数字签名在以太坊中有三种用途。首先，签名证明私钥的所有者，暗示着以太坊账户的所有者，已经授权支付ether或执行合约。其次，授权的证明是_undeniable_（不可否认）。第三，签名证明交易数据在交易签名后没有也不能被任何人修改。



### 3.1 ECDSA(Elliptic Curve Digital Signature Algorithm)

- spec256k1，特定的椭圆曲线称为secp256k1，即曲线 y² = x³ + 7 在有限域 （⼜名伽罗瓦域）。
- spec256r1，secp256k1和secp*256r1*都是ECDSA(椭圆曲线数字签名算法)曲线的参数,区别是他们所使用的随机质数不同,目前行业内对于r1算法的安全性存疑。

​	都属于椭圆曲线数字签名算法ECDSA签名的具体实现，只是椭圆曲线函数不同。是由 NIST(National Institute of Standards and Technology)这个组织确定的。



- ECDSA存在的七宗罪
  - 如果签名过程中随机数值泄露, 则任何知道该随机数值的⼈可以使⽤该随机数产⽣签名值恢复私钥
  - 如果同一个用户对两个不同的消息签名时,采用了相同的随机数,则则任何⼈都可以通过两个签名值恢复出私钥
  - 如果两个用户执行ECDSA签名时采用了相同的随机数,则两人中的任何一方可以推算出另一方的私钥
  - 如果相同的私钥和随机数被同时用于ECDSA签名和Schnorr签名,则任何⼈都能够恢复出私钥
  - ECDSA签名值的可锻造性带来的安全隐患
  - ECDSA签名值的DER编码的不唯一性会带来的安全隐患
  - 如果验签时不要求提供被签名的消息,则任何人都可以伪造签名值

### 3.2 EdDSA (Edwards-curve Digital Signature Algorithm)

- ed25519，属于EdDSA签名算法的具体实现，是由ANFS组织推进的ed25519密钥体系相关进展。

  

​	ECDSA安全以及执行效率的问题, 要求在工程手段之外更为深度的改进, 一个自然的方向是重新构建椭圆曲线以及签名机制以便在多个层次上同时改进: 改进底层算术运算加速中层点群运算, 中层点群运算适配上层协议, 并在上层签名机制设计时同时考虑 ECDSA 签名机制的问题与局限性加以避免. EdDSA (Edwards-curve Digital Signature Algorithm) 签名机制是这个研究方向上的成果。

​	EdDSA 签名机制是 Bernstein 等人在 2012 年设计的基于爱德华曲线 (Edwards Curves) 的数字签名算法。EdDSA 签名机制是 Schnorr 签名机制的一个变种, 其设计初衷是在不牺牲安全性的前提下提升签名/验签速 度, 并同时解决前述的 ECDSA 在应用方面存在的一些问题.



### 3.3 多重签名

众所周知，一个数字货币所有权的三要素为：地址(Address)，公钥(Public Key)，私钥(Private Key)。地址相当于大家的银行账户；公钥由本人公开，用于加密和验证签名；而私钥用来进行解密和签名，是数字货币所属权的表征，相当于银行卡的密码。

常规的账户或者轻钱包都是一个数字货币地址对应一个私钥，动用这个地址中的资金需要私钥的掌握者发起签名才行。而多重签名（multi-sig）技术，也叫M-of-N多重签名，在比特币中，用N把钥匙生成一个多重签名的地址，需要其中M把钥匙才能花费这个地址上的比特币，N>=M，这就是M-of-N的多重签名。比如说，某笔资金对应有3个私钥，而必须至少有其中任意2个私钥参与签名才能动用，只有1个私钥参与签名则是无效的。

#### 3.3.1 多重签名的作用

- **联名账户（多方共同管理资产）**

  ​	通过提供多方的地址，比特币变得“被束缚”，因此需要这些方的合作才能与他们进行任何交易。这些团体可以是人员，机构或程序脚本。

- **提高安全性**

  ​	从钱包中花费的私钥可以分布在多台机器上，从而消除了其中任何一台机器的故障，其理由是恶意软件和黑客不太可能感染所有机器。花费资金所需的密钥数量越多（即M等于N的M越高），攻击者成功窃取您的资金就越困难，但是实际使用该钱包的麻烦就越大。

- **秘钥备份。**

  ​	将多个密钥存储在不同位置的M-of-N钱包中可以用作备份。例如，在2之3的多重签名钱包中，一个密钥的丢失不会导致该钱包的丢失，因为其他两个密钥可用于回收资金。备份的冗余为差值N减去M，因此，例如3 of 5 multisig钱包（无其他种子备份）的冗余为2，这意味着仍可从中恢复任何2个密钥的丢失。

## 4. 比特币改进建议 BIP: Bitcoin Improvement Proposals 

### 4.1 BIP32

​	钱包也是一个私钥的容器，按照上面的方法，我们可以生成一堆私钥（一个人也有很多账号的需求，可以更好保护隐私），而每个私钥都需要备份就特别麻烦的。

​	为了解决这种麻烦，就有了[BIP32 提议](https://link.zhihu.com/?target=https%3A//github.com/bitcoin/bips/blob/master/bip-0032.mediawiki)： 根据一个随机数种子通过分层确定性推导的方式得到n个私钥，这样保存的时候，只需要保存一个种子就可以，私钥可以推导出来，如图：

<img src="https://img.learnblockchain.cn/2018/450b5358b96ef5b32ec775efed901f2a.png!wl/scale/50" alt="推导" style="zoom:50%;" />

> BIP32提案的名字是：Hierarchical Deterministic Wallets 分层确定性钱包， 就是我们所说的HD钱包。


来分析下这个分层推导的过程，第一步推导主秘钥的过程：

<img src="https://img.learnblockchain.cn/2018/3ec7468aa49d907b0ec66b5d8b41a0a1.png!wl/scale/40" alt="推导主秘钥的过程" style="zoom:50%;" />

根种子输入到HMAC-SHA512算法中就可以得到一个可用来创造主私钥(m) 和 一个主链编码（ a master chain code)这一步生成的秘钥（由私钥或公钥）及主链编码再加上一个索引号，将作为HMAC-SHA512算法的输入继续衍生出下一层的私钥及链编码，如下图：

<img src="https://img.learnblockchain.cn/2018/a9a6e6a31f39e812f579a4c8bdf09347.png!wl/scale/40" alt="衍生" style="zoom:50%;" />

> 衍生推导的方案其实有两个：一个用父私钥推导（称为强化衍生方程），一个用父公钥推导。同时为了区分这两种不同的衍生，在索引号也进行了区分，索引号小于2^31用于常规衍生，而2^31到2^32-1之间用于强化衍生，为了方便表示索引号i'，表示2^31+i。

因此增加索引（水平扩展）及 通过子秘钥向下一层（深度扩展）可以无限生成私钥。

注意， 这个推导过程是确定（相同的输入，总是有相同的输出）也是单向的，子密钥不能推导出同层级的兄弟密钥，也不能推出父密钥。如果没有子链码也不能推导出孙密钥。现在我们已经对分层推导有了认识。

一句话概括下BIP32就是：**为了避免管理一堆私钥的麻烦提出的分层推导方案。**



### 4.2 BIP44

通过这种分层（树状结构）推导出来的秘钥，通常用路径来表示，每个级别之间用斜杠 / 来表示，由主私钥衍生出的私钥起始以“m”打头。因此，第一个母密钥生成的子私钥是m/0。第一个公共钥匙是M/0。第一个子密钥的子密钥就是m/0/1，以此类推。

BIP44则是为这个路径约定了一个规范的含义(也扩展了对多币种的支持)，BIP0044指定了包含5个预定义树状层级的结构：

```
m / purpose' / coin' / account' / change / address_index
```

m是固定的, Purpose也是固定的，值为44（或者 0x8000002C），’为hardend模式



- **Coin type**
  这个代表的是币种，0代表比特币，1代表比特币测试链，60代表[以太坊](https://learnblockchain.cn/2017/11/20/whatiseth/)
  完整的币种列表地址：https://github.com/satoshilabs/slips/blob/master/slip-0044.md
- **Account**
  代表这个币的账户索引，从0开始
- **Change**
  常量0用于外部(收款地址)，常量1用于内部（也称为找零地址）。外部用于在钱包外可见的地址（例如，用于接收付款）。内部链用于在钱包外部不可见的地址，用于返回交易变更。 (所以一般使用0)
- **address_index**
  这就是地址索引，从0开始，代表生成第几个地址，官方建议，每个account下的address_index不要超过20

根据 [EIP85提议的讨论](https://github.com/ethereum/EIPs/issues/85)以太坊钱包也遵循BIP44标准，确定路径是`m/44'/60'/a'/0/n`
a 表示帐号，n 是第 n 生成的地址，60 是在 [SLIP44 提案](https://github.com/satoshilabs/slips/blob/master/slip-0044.md)中确定的以太坊的编码。所以我们要开发以太坊钱包同样需要对比特币的钱包提案BIP32、BIP39有所了解。

一句话概括下BIP44就是：**给BIP32的分层路径定义规范**



### 4.3 BIP39

​	BIP32 提案可以让我们保存一个随机数种子（通常16进制数表示），而不是一堆秘钥，确实方便一些，不过用户使用起来(比如冷备份)也比较繁琐，这就出现了[BIP39](https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki)，它是使用助记词的方式，生成种子的，这样用户只需要记住12（或24）个单词，单词序列通过 PBKDF2 与 HMAC-SHA512 函数创建出随机种子作为 BIP32 的种子。

#### 助记词生成

助记词生成的过程是这样的：先生成一个128位随机数，再加上对随机数做的校验4位，得到132位的一个数，然后按每11位做切分，这样就有了12个二进制数，然后用每个数去查[BIP39定义的单词表](https://github.com/bitcoin/bips/blob/master/bip-0039/bip-0039-wordlists.md)，这样就得到12个助记词，这个过程图示如下：

![过程图](https://img.learnblockchain.cn/2018/71c0af9474a51296096c3c806ca8f1a1.png!wl/scale/70)

#### 助记词推导出种子

这个过程使用密钥拉伸（Key stretching）函数，被用来增强弱密钥的安全性，PBKDF2是常用的密钥拉伸算法中的一种。
PBKDF2基本原理是通过一个为随机函数(例如 HMAC 函数)，把助记词明文和盐值作为输入参数，然后重复进行运算最终产生生成一个更长的（512 位）密钥种子。这个种子再构建一个确定性钱包并派生出它的密钥。

密钥拉伸函数需要两个参数：助记词和盐。盐可以提高暴力破解的难度。 盐由常量字符串 "mnemonic" 及一个可选的密码组成，注意使用不同密码，则拉伸函数在使用同一个助记词的情况下会产生一个不同的种子，这个过程图示图下:

![过程图](https://img.learnblockchain.cn/2018/d37f78f8f2d859369d99fc5e0a76c184.png!wl/scale/80)





## 总结

（128位随机数+4位校验随机数）按照bip32单词表 -> **助记词**  

**助记词**  + salt -> PBKDF2算法（使用HMAC-SHA512） ->  **种子（512位）** -> **私钥（前256位）chain code链码（后256位）**

私钥 -> 椭圆曲线算法（例如：spec256k1、ED25519）-> 公钥

```
master_private_key   根私钥
master_public_key		 根公钥
master_chain_code    链码
```

<img src="/Users/oker/Library/Application Support/typora-user-images/image-20230411102003895.png" alt="image-20230411102003895" style="zoom:50%;" />

三种私钥派生规则

- Hardend Child: extended private key

  - 根私钥—>子私钥—>子公钥—>地址

  - 子私钥 = (父私钥 + HMAC-SHA512(父私钥+链码+index)) % n
  - hardend模式下，index必须为2^31 - 2^32-1

- Nomal Child: extended private key
  - 根私钥—>子私钥—>子公钥—>地址
  - 子私钥 = (父私钥 + HMAC-SHA512(父公钥+链码+index)) % n

- Nomal Child: extended public key
  - 根公钥—>子公钥—>地址
  - 子公钥 = 父公钥 + HMAC-SHA512(父公钥+链码+index)



<img src="/Users/oker/Library/Application Support/typora-user-images/image-20230411102807198.png" alt="image-20230411102807198" style="zoom: 33%;" />

<img src="/Users/oker/Library/Application Support/typora-user-images/image-20230411104612666.png" alt="image-20230411104612666" style="zoom:33%;" />
