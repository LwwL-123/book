# 椭圆曲线签名算法

> 本文节选自：https://blog.csdn.net/gitcoins/article/details/125938207

## 1. 椭圆曲线

像这样的式子 y² = x³+ax+b 在a和b的关系（4a³+27b² ≠ 0）约束下， 通常画出来是个椭圆曲线，我们以a等于-1，b等于9为例，y² = x³ - x + 9 来说清楚椭圆曲线，当x固定时，y等于正负开根号这个式子（y= ± √x³ - x + 9 ），也就是说任意一个X，都会有两个Y，一正一负，使等式成立。如果这个关系用横坐标表示X，用纵坐标表示Y时，画出来是一个以X轴对称的椭圆曲线图形。

![在这里插入图片描述](https://picture-1258612855.cos.ap-shanghai.myqcloud.com/202304121019101.png)

椭圆曲线需要简单的高中数学知识，如果你对刚才的内容还是不理解，请查查资料，在坐标系上手动画画，就有一副美丽的曲线呈现在你的面前。y² = x³ - x + 9 这个椭圆曲线当X为0时，Y得到正负3，同样当X为1时，Y等于正负3。 我们把（-1,-3）称之为P点，（1,3）称之为Q点，画一条直线，因为是椭圆曲线，只要直线不与Y轴平行，那他们必会有第三个交点，我们称之为R点。

![在这里插入图片描述](https://picture-1258612855.cos.ap-shanghai.myqcloud.com/202304121020049.png)

## 2. 两点定一直线

那R点究竟是什么？我们通过P和Q点可以确定一条直线，直线的斜率是(Y2 - Y1)/(X2 - X1) 得到3，与Y轴的焦点是负3，所以P和Q确定的直线是 Y等于3X （y=3x）

![在这里插入图片描述](https://picture-1258612855.cos.ap-shanghai.myqcloud.com/202304121020076.png)

## 3. 直线和曲线相交

那这条直线与椭圆曲线的交点有几个？
我们把直线方程带入到曲线方程中就可以得到

> (3x)² = x³ - x + 9
> x³ - 9x² -x + 9 = 0

这个等式一共有三个解

> x = 0, 1, 9

把X带入直线公式
那么与椭圆曲线相交的点为

> P（0， -3） Q（1， 3） R（9， 27）

也就是第是三个点为（9， 27）

![在这里插入图片描述](https://picture-1258612855.cos.ap-shanghai.myqcloud.com/202304121020741.png)

## 4. 不断迭代的动力

因为椭圆曲线是X轴对称图像那么一定有一个 -R（9， -27）点也在椭圆曲线上。-R点再和P点在连成一条直线，这条直线与椭圆曲线相交在S点上。有S点就一定有负S点，负S再和P点在连成一条直线，这条直线将与椭圆曲线相交在T点上。数学家定义P+Q=-R， -R+P=-S。

![在这里插入图片描述](https://picture-1258612855.cos.ap-shanghai.myqcloud.com/202304121020467.png)

如何定义不重要，重要的是能按照这个逻辑找到相应的点。不断发现新的相交点，不断的找到相交点的对称点，不断的与P点连成直线，就像一个永动机一样，不断地迭代。

![在这里插入图片描述](https://picture-1258612855.cos.ap-shanghai.myqcloud.com/202304121020446.png)

## 5. 当P和Q为同一点时

那P+P是什么意思呢？同样两个点相加表示椭圆曲线P点的切线，也就是P点的切线无限延伸后，能找到与椭圆曲线相交的第二个点Q，那么-Q一定在椭圆曲线上，我们把-R有叫做2P，叫什么没有关系，关键是你只知道是哪个点就好，同理可以利用不断迭代的办法，我们将2P和P再连成直线，找到椭圆曲线的交点，找到交点的对称点，得到3P。同理我们可以得到4P、5P等等。NP代表着需要寻找N次。

![在这里插入图片描述](https://picture-1258612855.cos.ap-shanghai.myqcloud.com/202304121020358.png)

## 6. 快速计算

引入P+P的模式有一个好处就是快速寻找，指数级别地缩短了寻找结果。我们以寻找4P和8P为例，当我们找到2P后，将2P点的切线无限延伸，找到椭圆曲线的交点，找到交点的对称点，得到4P，这就是2P+2P的计算过程。也就是我们不在通过3P的结果找到4P，同理8P也可以由两个4P相加而成，不在经过5P到6P到7P这样的寻找过程。这样的寻找方式，大大的降低了寻找的次数。

![在这里插入图片描述](https://picture-1258612855.cos.ap-shanghai.myqcloud.com/202304121020497.png)

比如我们要计算32P，传统方式要计算32次，快速寻找办法我们可以计算2P后直接计算4P，然后8P、16P到32P，只需要4次计算。比如我们计算1029P，那我们就可以将1049分解成1024P + 4P + 1P，得到1024P需要10次计算，共需要12次完成整个计算。因此引入P+P是极大的降低了计算次数，提升了寻找速度。

![在这里插入图片描述](https://picture-1258612855.cos.ap-shanghai.myqcloud.com/202304121020593.png)

> n•P+r•P = (n+r)•P
> x³ - 9x² -x + 9 = 0
> 210²
> 2¹⁰ P + 2² P + 2⁰ P
> 2[10]

迭代和加密的关系
那迭代的内动力和加密算法和数字签名有什么关系？因为椭圆曲线的这种特性是单向的，P经过5次相加后，我可以计算出5P的位置。但是，如果我们知道5P这个点，然后反推是由几次P相加的，这个没有直接计算方式，所以称之为单向的。我们只能计算2P后和结果比对，看是不是和5P一样，不是那就继续3P、4P结果比较，直到结果一样，我们才能知道次数是5次。

![在这里插入图片描述](https://picture-1258612855.cos.ap-shanghai.myqcloud.com/202304121020246.png)

那如果这个数非常大呢？我们一个一个计算需要很长时间。在非对称加密算法中，把一个非常大的数k作为私钥，将kP这个点作为公钥。

![在这里插入图片描述](https://picture-1258612855.cos.ap-shanghai.myqcloud.com/202304121020355.png)

之前的非对称加密模型也讨论过，kP作为公钥分发给任何人，即使是黑客，他也无法反推出k。k牢牢的掌握在创建密钥对的人手中。

![在这里插入图片描述](https://picture-1258612855.cos.ap-shanghai.myqcloud.com/202304121020852.png)

## 7. 比特币中的椭圆曲线算法

比特币种的椭圆曲线采用A等于0，B等于7

> y² = x³+7

P的横坐标和纵坐标分别是很大的数，在比特币中我们把出发的这个点称之为generator，用G来表示。

> _Gx = 0x79BE667EF9DCBBAC55A06295CE870B07029BFCDB2DCE28D959F2815B16F81798L
> _Gy = 0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8L

如果我们创建了很大的随机数作为私钥

> _k = 0x1E99423A4ED27608A15A2616A2B0E9E52CED330AC530EDCC32C8FFC6A526AEDD

那么公钥就是k个G相加后得到的一个点，我们称之为大K点。 _k * G 这个点

> _Kx = F028892BAD7ED57D2FB57BF33081D5CFCF6F9ED3D3D7F159C2E2FFF579DC341A
> _Ky = 07CF33DA18BD734C600B96A72BBC4749D5141C90EC8AC328AE52DDFE2E505BDB

公钥在比特币中不是按照点来描述的，而是以04打头，X坐标值和Y坐标值一一串连起来的。表示为(04 x y)

> K = 04F028892BAD7ED57D2FB57BF33081D5CFCF6F9ED3D3D7F159C2E2FFF579DC341A-07CF33DA18BD734C600B96A72BBC4749D5141C90EC8AC328AE52DDFE2E505BDB

然后用一个简单的压缩算法，保留X或Y的其中一个就行了。这是以03打头，后跟着X坐标值，这就是人们最后看到的公钥。

> K = 03F028892BAD7ED57D2FB57BF33081D5CFCF6F9ED3D3D7F159C2E2FFF579DC341A

我们可以看到私钥小K的取值非常大，所以很难通过公钥的信息反推出私钥的值。

## 8. 如何实现数字签名

那如何利用椭圆曲线实现数字签名算法，之前视频讨论过非对称加密算法将数据和私钥形成签名，因为只有Alice有自己的私钥，所以用私钥签发的文件，BoB接收后是可证明是Alice签发的。签名的目的在数据的基础上通过私钥形成一种独特的印记，将印记发给Bob，Bob可以利用Alice的公钥证明这个印记是Alice独有的，其他人不可能生成这个印记。

![在这里插入图片描述](https://picture-1258612855.cos.ap-shanghai.myqcloud.com/202304121020000.png)

我们来尝试一下，如何通过椭圆曲线是实现签名的。Alice向Bob发送消息M，
Alice的私钥是小K，公钥是大K。K = _k * G

在Alice发送M消息之前，我们将私钥乘以M的哈希值作为签名（_s）

> (hash(m)*_k) * G = _s *G

将M和_s发送给Bob
公钥K在Alice向Bob发送消息前就给到Bob了，G点是比特币椭圆曲线算法里固定的点，这个点是公开信息。

> Bob:
> hash(M) * K = X
> _s * G = Y

如果Y=X，那说明_s 中包含了_k的信息，_s一定是Alice的签名。

我们来看一下为什么？

> Y = _s*G = (hash(m)*_k) * G = hash(m) * _k * G = hash(m) * K = X，

![在这里插入图片描述](https://picture-1258612855.cos.ap-shanghai.myqcloud.com/202304121020365.png)

在整个证明过程中，我们从小S开始证明，小K作为证明X=Y的桥梁，没有小K，无法证明X=Y，这个过程说明了_k是_s的核心参数，如果Alice没有_k就不会制造出_s, 这个计算过程Alice清楚，但是Bob并不清楚计算过程，Bob只要验证Y=X，就说明了_s一定是_k制造出来的，因为只有Alice拥有_k,那么_s一定是Alice制造出来的。这种方法是，Bob不能直接知道Alice的私钥，但是Bob可以证明签名是Alice的私钥做出来的。就像专家鉴定张大千的字画，张大千本身就是私钥，他的画作就是他的签名，我们在没有张大千的世界里，证明这是张大千画的。但是我们尝试的这个方案还是有问题。Bob可以通过小S除以消息M的哈希值得到Alice的私钥，这样Alice私钥就暴露了。

![在这里插入图片描述](https://picture-1258612855.cos.ap-shanghai.myqcloud.com/202304121021328.png)

为此数学家们又想出了一个办法。引入R，R类似于非对称加密的用法一样，将R公开，小R保留在自己手上。

> R = _r * G

Alice的签名为：

> （hash(m)*_k + _r） * G = _s * G

将M、R和_s发送给Bob

> Bob:
> hash(M) * K + R = X
> _s * G = Y

如果Y=X，那说明_s 中包含了_k的信息，_s一定是Alice的签名。

> Y = _sG = (hash(m)_k + _r) * G = hash(m) * _k * G + _r *G = hash(m) * K + R = X，

![在这里插入图片描述](https://picture-1258612855.cos.ap-shanghai.myqcloud.com/202304121021223.png)

在整个证明过程中，我们从数字签名小S开始证明，小K和小R作为证明X=Y的桥梁，没有小K和小R，无法证明X=Y，如果Alice没有_k和小R就不会制造出_s, 这个计算过程Alice清楚，但是Bob并不清楚计算过程，Bob只要验证Y=X，就说明了_s一定是_k和小R制造出来的，因为只有Alice拥有_k和小R,那么_s一定是Alice制造出来的。而且这个解决方案是安全的，Bob知道 _s = hash(m)*_k + _r 这个公式，这个公式已知小S和M，但Bob无法计算出小K和小R。这样数学家就找到了一种方案，Alice不暴露私钥小K和小R，但是能让Bob通过公钥K等信息证明是Alice发过来的消息。

![在这里插入图片描述](https://picture-1258612855.cos.ap-shanghai.myqcloud.com/202304121021500.png)

比特币中的R
在比特币中，G点的X和Y的值，私钥小K的值，小R的值，都是256位的数。由于椭圆曲线是无限延伸的，我们找到的K点和R点的X和Y的值可能是一个非常大的值，有的甚至大到没法处理，为此引入了P的概念，让所有的点都在P的范围内，找到的点的X和Y值都要进行取模运算（MOD），确保大小不要超过P的值。所以比特币的椭圆曲线表示为：

> _r = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141L
> _p = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2FL
> y² mod p = (x³ + 7) mod p

![在这里插入图片描述](https://picture-1258612855.cos.ap-shanghai.myqcloud.com/202304121021095.png)