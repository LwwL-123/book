# 比特币地址

## 1. 压缩地址

### 1.1 私钥

```text
e8d96a53e9c597e5a1e2ceaddd0b5ebe75588b26e71846b46a9b5f366640935501   压缩
e8d96a53e9c597e5a1e2ceaddd0b5ebe75588b26e71846b46a9b5f3666409355     非压缩
```

之后经过Base58 +校验（Base58Check）处理得到我们常用的WIF私钥：

私钥前缀80+私钥本体+后缀（压缩私钥后缀01，非压缩私钥无后缀）+校验（为了方便观察，我用回车给它们加过换行，实际不换行）

- 压缩私钥 (76位十六进制 2+64+2+8) <=>（52位Base58）

```text
80
e8d96a53e9c597e5a1e2ceaddd0b5ebe75588b26e71846b46a9b5f3666409355
01
dd183916

L52LeAjvxeDgPeN2p4ouku7pHLrnbZCX6SH6F5wuqdC1AftywpWR
```

- 非压缩私钥 (74位十六进制 2+64+8) <=>（51位Base58）

```text
80
e8d96a53e9c597e5a1e2ceaddd0b5ebe75588b26e71846b46a9b5f3666409355
f4b0f677

5KaqQNh5yZSyxRn6Pu4qCkypsNie4kYcNAohA5kFh1x4DGUQVV8
```

压缩私钥是后来者，为防止与旧版混淆而区别表示。

WIF私钥（钱包Wallet导入Import格式Format，常用的格式）

```text
L52LeAjvxeDgPeN2p4ouku7pHLrnbZCX6SH6F5wuqdC1AftywpWR    压缩私钥
5KaqQNh5yZSyxRn6Pu4qCkypsNie4kYcNAohA5kFh1x4DGUQVV8     非压缩私钥
```

### 1.2 公钥

非压缩公钥(130位十六进制 2+64+64)

```text
04
1DC1A701EBB8EF3FC55093E25D78DCB56D21F11DD88D62714549A38539978D9D
8C953064030B72C6D468DE2676ACB46197297124FBA4F58A3ADBFF93F8D58376
```

压缩公钥（66位十六进制 2+64）

```text
02
1DC1A701EBB8EF3FC55093E25D78DCB56D21F11DD88D62714549A38539978D9D
```

- 非压缩公钥是04开头
- 压缩公钥是02或03开头。

注意它们的第二行内容完全一样。

### 1.3 地址

```text
15aeAiNmHqqHJLJqaSEwMwdft4uMxJZ4Mb    压缩地址
189Sirx5GdVZrkPXSBSrtz1j8yvxJ26L2d    非压缩地址
```

### 1.4 总结

- 它们之间的关系：
  - 同一个私钥压缩前后在数值上相等，写法不同，可以互相转换。
  - 压缩私钥对应的地址与非压缩私钥对应的地址没有关系，不能相互推导。
- 使用压缩地址给我们的影响：
  - 压缩地址和非压缩地址在使用上没有任何区别。
  - 压缩私钥在上古版本的软件中可能不被支持，在新版软件上没有区别。
  - 非压缩私钥的WIF格式是51位的Base58Check，数字5开头。
  - 压缩私钥的WIF格式是52位的Base58Check，字母K或L开头。
  - 压缩私钥只对应压缩地址，非压缩私钥只对应非压缩地址，即使两个私钥数值相等，也绝不兼容，一个私钥只能得到一个地址，拒绝任何形式的混淆。
- 为什么要使用压缩：
  - 常规交易的输入包含支付者的公钥，每一个压缩公钥比非压缩公钥节约一点点空间
- 为什么压缩私钥要长：
  - 多了一个01后缀

- 为什么压缩地址和非压缩地址一样长：
  - 因为用公钥推出地址的公式是RIPEMD160(SHA256(x))，无论公钥多长，最终结果都是160位二进制，也就是所谓的hash160，Base58+校验后26~34位。



## 2. P2PKH地址和WIF

比特币地址是一串字母和数字的组合，收款时你可以放心地把它分享给发款方。**地址既不是你的钱包私钥也不是公钥**，别人光知道地址是无法动用你的资金的，不过可以根据公开的区块链信息查阅所有进出这个地址的交易记录。

比特币地址有几种形式。最常见的莫过于以数字“1”开头的P2PKH（Pay-to-Public-Key-Hash）地址，例如1Nekoo5VTe7yQQ8WFqrva2UbdyRMVYCP1t。它表示的是最简单的、用一对私钥和公钥控制的钱包。

另一种越来越普及的格式是以数字“3”开头的P2SH（Pay-to-Script-Hash）地址，例如3MotoZaxiHoCTDXuAjWXRHP37mprGAAEKU。多重签名、SegWit以及一些智能合约（没错，比特币也支持简单的智能合约）通常都采用这种“3”型地址。

以“2”、“m”或“n”开头的地址非常罕见，仅仅被用于比特币的测试网络。首字符的不同让我们很容易区分它们的用途，也能防止主链的币被误发到测试网络上。

首字符是“5”、“K”或“L”的不是地址，而是WIF（Wallet Import Format）格式的私钥，务必要妥善保管，不可泄漏。



以下将详细讲解P2PKH地址的生成步骤：

1. 首先随机生成一个256位的私钥P，例如：

```
P = 0x9B257AD1E78C14794FBE9DC60B724B375FDE5D0FB2415538820D0D929C4AD436
```

2. 其次求出P对应的公钥K：

```
K = 0x0497FCFAA24237514FD4C00A33491F835D7D019DE4E9CEB0E24916371BAE329E
    622260575B83A1542D93418DABBBE65109B4E27A1A0737B2FD980698C3D0188839
```

K的首字节0x04是类型标记，表示无压缩公钥。之后紧跟的分别是256位的x和y坐标，共计65字节。（x, y）坐标对应的是方程y² mod p = (x³ + 7) mod p在一个有限域上的整数解（p是个接近2^256的庞大质数）。

由于p是个固定值，所以在已知x的情况下，我们可以求算出y的两个解。在实数域上它们显然是一正一负两个值；而在secp256k1椭圆曲线的整数域上则是一奇一偶两个数。那么只需记录x坐标和y的奇偶性（而不是y本身），我们就能砍掉近一半的空间表示同样的公钥：

```text
K' = 0x0397FCFAA24237514FD4C00A33491F835D7D019DE4E9CEB0E24916371BAE329E62
```

这个K'被称为压缩公钥，首字节是0x02（偶数y）或0x03（奇数y），共计33字节。

3. 依次用SHA-256和RIPEMD160求算K'的双重哈希H：

```text
H = RIPEMD160(SHA256(K'))
  = RIPEMD160(0x400952fb04739c06cc9f84c8ce35c83d311b97d7485be9a0ea7ae74d27a0ead4)
  = 0xed7e99a18a7e2f4307240a8936149e7b172007a3
```

然后在160位的哈希H前添上代表版本的0x00前缀，再对这21个字节算两次SHA-256，取前四个字节作为校验码C：

```text
C = CHECK(0x00 + H)
  = SLICE(SHA256(SHA256(0x00 + H)), 0, 4)
  = SLICE(SHA256(SHA256(0x00ed7e99a18a7e2f4307240a8936149e7b172007a3)), 0, 4)
  = SLICE(SHA256(0x1299fd46aa462709ad88e102d2f013a7381e33b0700ee9e7150d6ad115eb2576), 0, 4)
  = SLICE(0x4e377c733f5e52853e012060c30dd504a9060e93b34b34e379a8bc3959298077, 0, 4)
  = 0x4e377c73
```

最后把0x00、H、C串在一起，作Base58编码得到最终的P2PKH地址A：

```text
A = Base58(0x00 + H + C)
  = Base58(0x00ed7e99a18a7e2f4307240a8936149e7b172007a34e377c73)
  = "1Nekoo5VTe7yQQ8WFqrva2UbdyRMVYCP1t"
```

Base58类似于常用的Base64变换。它从大小写英文字母加数字的集合中去掉了四个容易引起混淆的字符（数字零：“0”，大写的o：“O”，小写的L：“l”，大写的i：“I”），用以下的58个字符对输入数据编码：

```text
123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz
```

由Base58地址能很方便地推算出H和C，比较两者即可校验比特币地址的正确性。但从哈希H无法反推出公钥K和私钥P——除非SHA256和RIPEMD160这两个哈希函数都存在严重漏洞。

Base58不光用于地址，还能编码私钥，生成WIF（Wallet Import Format）格式的字符串，便于导入各种钱包软件。拿上文中的私钥P为例：

```text
WIF = Base58(0x80 + P + CHECK(0x80 + P) + 0x01)
    = Base58(0x80 +
             0x9B257AD1E78C14794FBE9DC60B724B375FDE5D0FB2415538820D0D929C4AD436 +
             0x36dfd253 +
             0x01)
    = "L2RJ5NYR3qJLdmbaNPVfvNWSqG9g9XwcLZSuni8aT9u4y4dN1c3J"
```

其中前缀0x80表示私钥类型。后缀0x01表示公钥采用压缩格式（K'）。如果用非压缩公钥（K）则不加这个后缀，不过没有任何理由需要使用非压缩公钥。

最后探讨一下中本聪的设计思路。首先为什么不直接拿公钥做地址呢？因为直接使用公钥的话太不灵活，无法方便地支持多重签名等需求。而且用哈希可以缩短地址长度。

那为什么SHA256之后还要用RIPEMD160再次哈希呢？RIPEMD160可以在不增加太多哈希冲突的情况下让地址更短一些。更主要的原因可能是为了防止单一哈希存在现在未知的漏洞，降低系统的安全性。

加上四字节的校验码能帮助我们快速检验地址是否输入正确。这个校验不需要太强的安全性，四个字节绰绰有余了。我个人认为截取第一次SHA256的前几个字节就足够，双重SHA256没有什么特别好处。

至于加0x00、0x80等前缀则显然是明智的设计。它不仅给未来的格式扩展打下了基础，还通过Base58后的首字符反映出编码数据的类型，方便我们快速识别。



## 3. P2SH地址与multisig

上一篇介绍了首字符是“1”的P2PKH（Pay-to-Public-Key-Hash）地址。它由一个公钥的哈希构成。任何人都可以向它转入资金，但只有掌握对应的私钥才能转出资金。转出时需要出示交易的私钥签名和公钥。秘钥本身并不透露。

P2PKH的上锁逻辑直接写入交易的输出，脚本形式是：

```text
DUP HASH160 PUSHDATA(目标公钥哈希) EQUALVERIFY CHECKSIG
```

这是比特币脚本语言中的一段脚本代码。以下是对每个操作符的解释：

- DUP：将栈顶元素复制一份并压入栈顶。
- HASH160：计算栈顶元素的 RIPEMD160 哈希，并将结果压入栈顶。
- PUSHDATA：将指定的数据推入栈顶。
- 目标公钥哈希：包含了20字节的公钥哈希（公钥→SHA256→RIPEMD160）。
- EQUALVERIFY：检查栈顶的两个元素是否相等，并将结果放回栈顶。如果相等，继续执行；如果不相等，立即终止脚本执行。
- CHECKSIG：使用栈顶的公钥和签名对当前交易进行验证。
  这段脚本的作用是验证一个交易的签名是否与给定的公钥对应，并且公钥的哈希值与目标公钥哈希相匹配。如果验证成功，脚本将返回 True；否则，返回 False。

对应的解锁脚本是：

```text
PUSHDATA(签名) PUSHDATA(公钥)
```

第一个PUSHDATA包含用DER编码的椭圆曲线签名。长度通常是71、72或73字节，也有小概率会更短。第二个PUSHDATA包含的则是公钥。压缩形式的公钥长度33字节，非压缩形式长65字节。为了减少交易大小和交易费，通常都采用压缩公钥。



解锁脚本的验证步骤如下所示。方括号表示虚拟机的堆栈状态，栈顶在尾部：

```text
   // 首先运行解锁脚本
0: [] // 初始状态：空堆栈
1: [签名] // PUSHDATA 入栈签名
2: [签名, 公钥] // PUSHDATA 入栈公钥
   // 复制堆栈后运行上锁脚本
3: [签名, 公钥, 公钥] // DUP 复制栈顶公钥
4: [签名, 公钥, 公钥哈希] // HASH160 取出栈顶公钥，压入它的哈希
5: [签名, 公钥, 公钥哈希, 目标公钥哈希] // PUSHDATA 入栈目标公钥哈希
6: [签名, 公钥] // EQUALVERIFY 取出栈顶两个哈希，确认它们等值，否则验证失败
7: [TRUE] // CHECKSIG 取出栈顶的公钥和签名，验证交易，入栈检查结果
   // 栈顶为真值则验证成功
```

由此可见，P2PKH缺乏灵活性，无法支持复杂的需求，比如允许三个人中任意两个动用资金之类。为了丰富比特币的功能，BIP-16改进方案在2012年引入了首字符是“3”的P2SH（Pay-to-Script-Hash）地址。它常被谬称为多重签名（multi-signature或multisig）地址，因为multisig都以这种形式实现，但P2SH还能用于其他加密方式。今年八月激活的隔离见证（SegWit）也常以P2SH包裹，做到向后兼容。



P2SH的灵活性来自于它巧妙的设计——交易的输出并不像P2PKH那样直接保存上锁脚本，而是记录20字节的脚本哈希，形式是这样的：

```text
HASH160 PUSHDATA(目标脚本哈希) EQUAL
```

光根据脚本哈希，外人无从推断出解锁的逻辑。等我们转账时才需要出示与该哈希对应的原始脚本，并且保证脚本的运行结果为真。

P2SH最常用于M-of-N多重签名，也就是在预定的N个公钥中，给出M个相应的签名就能通过验证（1 ≤ M ≤ N）。我们来看个2-of-3 multisig的具体例子。

先生成三组私钥和压缩形式的公钥。这个过程通常由三个人私下完成，各自保管自己的私钥：

```text
私钥A:
L2iQ55QcE6otmfUZPLYU2Qf5SP41HhCtPEKu2v3r16vHZ19MT7Sn
公钥A:
020FA7BED1B89DF218A2ED2C94EBBF872A7BDA0F48D231EB8CB6F16B87D9BB5211

私钥B:
L37gNgdvmLJuLNre3EASs2ETkEvrUn8AShviJTD2TfNaqWiEgwRT
公钥B:
02D7E287092457F2BEA226CD7537C5EE99AF50CCA923795A2EA65CF249F783C5D1

私钥C:
Kwd8QPXS1LZAGmqJDvb5emRtEPJuVjzXX2FRUZrYERMTt5uz58Vr
公钥C:
02E8B48F3C0A7C452792FA96CDCF2FC6A23298F4D6512BD8AA9A25210B66A1D450
```

用这三个公钥就能组合成2-of-3上锁脚本：

```text
2 PUSHDATA(公钥A) PUSHDATA(公钥B) PUSHDATA(公钥C) 3 CHECKMULTISIG
```

其中的2和3分别表示向堆栈压入数字2和3的操作。CHECKMULTISIG用于检查堆栈上的两个签名是否对应三个公钥中的两个。

以上脚本编译后的结果共计105字节，十六进制表示如下：

```text
5221020fa7bed1b89df218a2ed2c94ebbf872a7bda0f48d231eb8cb6f16b87d9
bb52112102d7e287092457f2bea226cd7537c5ee99af50cca923795a2ea65cf2
49f783c5d12102e8b48f3c0a7c452792fa96cdcf2fc6a23298f4d6512bd8aa9a
25210b66a1d45053ae
```

对它先求SHA256，得到32字节的哈希：

```text
6feec0468378f4a1f0c8dbccfd41f6041eaf0185d22d029d2dea4603ed8c94bf
```

再对以上结果做RIPEMD160，得到20字节的哈希：

```text
c19ba54b40598eab41f636b4b5c3fe6493dddd64
```

这就是P2SH上锁脚本中PUSHDATA里的目标脚本哈希。加上固定前缀0x05后作Base58Check编码便得到了最终的、首字符是“3”的P2SH地址：

```text
3KLio22Epg8nrXfzFBuoHWwxFPCkpFzYFo
```

转账时需要提供两个签名和原始脚本，解锁形式如下：

```text
0 PUSHDATA(签名D) PUSHDATA(签名E) PUSHDATA(脚本)
```

解锁过程比P2PKH稍复杂一些：

```text
   // 首先运行解锁脚本
0: [] // 初始状态：空堆栈
1: [0] // 0 被压入栈顶
2: [0, 签名D] // PUSHDATA 入栈第一个签名
3: [0, 签名D, 签名E] // PUSHDATA 入栈第二个签名
4: [0, 签名D, 签名E, 脚本] // PUSHDATA 入栈完整脚本
   // 复制堆栈后运行上锁脚本
5: [0, 签名D, 签名E, 脚本哈希] // HASH160 取出栈顶脚本，压入它的哈希
6: [0, 签名D, 签名E, 脚本哈希, 目标脚本哈希] // PUSHDATA 入栈目标脚本哈希
7: [0, 签名D, 签名E, TRUE] // EQUAL 取出栈顶两个哈希，判断是否相等，压入检测结果
   // 取出栈顶结果，如果非真，则验证失败，否则运行原始脚本
8: [0, 签名D, 签名E] // 准备运行原始脚本
9: [0, 签名D, 签名E, 2] // 2 被压入栈顶
10: [0, 签名D, 签名E, 2, 公钥A] // PUSHDATA 入栈第一个公钥
11: [0, 签名D, 签名E, 2, 公钥A, 公钥B] // PUSHDATA 入栈第二个公钥
12: [0, 签名D, 签名E, 2, 公钥A, 公钥B, 公钥C] // PUSHDATA 入栈第三个公钥
13: [0, 签名D, 签名E, 2, 公钥A, 公钥B, 公钥C, 3] // 3 被压入栈顶
14: [0, 签名D, 签名E, 2, 公钥A, 公钥B, 公钥C] // CHECKMULTISIG 先取出公钥数N(3)
15: [0, 签名D, 签名E, 2] // 接着取出N(3)个公钥
16: [0, 签名D, 签名E] // 再取出签名数M(2)
17: [TRUE] // 接着取出M(2)个签名和数字0，根据交易验证签名，压入检查结果
    // 栈顶为真则验证成功
```

细心的读者会发现最早入栈的数字零完全冗余，无助于签名验证。这是因为CHECKMULTISIG的代码实现存在一个bug，调用时会从堆栈上多取出一个数字。取出后它被立刻丢去，并不用于之后的运算。这个数具体是什么值无关紧要，可堆栈上不能缺失它，不然无法正常执行CHECKMULTISIG。为了保证共识机制的向后兼容，每个解锁脚本就多压入一个零，而CHECKMULTISIG实现代码里的错误只能年复一年地遗留下来，不通过硬分叉再也无法修复。



## 4. 隔离见证

## 4.1 案例

### 4.1.1 Pay-to-Witness-Public-Key-Hash

我们用例子来说明一下隔离见证会如何改变交易的数据结构。从标准的 Pay-to-Public-Key-Hash (P2PKH) 交易类型开始。

我们感兴趣的部分是输出，尤其是其 “scriptPubKey” 字段（锁定脚本字段）。我们先考虑一种标准的锁定脚本：

```
OP_DUP OP_HASH160 <PubKeyHash> OP_EQUALVERIFY OP_CHECKSIG
```

而隔离见证之后的锁定脚本如下所示：

```
0 <PubKeyHash>
```

如你所见，隔离见证的输出比传统类型的输出要简单很多：只有两个值会被推入脚本执行栈中。如我们上面说得，旧版本的比特币客户端会以为这个输出是掉在地上的钱 —— 无需提供签名就能花费这个输出。不过，新的客户端会将第一个数字解释为版本号，而第二个则对应着一个锁定脚本（witness 程序）。在现实中，只有压缩公钥（compressed public key）的哈希值可以用在这里。

再来看看这个输出被花费时的情形。传统交易的输出在花费时的数据结构如下：

```
[...]
"Vin" : [
 {
"txid": "8adbca5e652c68f8f3c30ac658115bc4af395d0cc7e6beaea18168295c29d011",
"vout": 0,
"scriptSig": "<our scriptSig>"
 }
]
[...]
```

但是，在花费一个隔离见证输出的时候，交易的 scriptSig 将为空，而所有的签名都会放到一个专门的地方：

```
[...]
"Vin" : [
 {
"txid": "8adbca5e652c68f8f3c30ac658115bc4af395d0cc7e6beaea18168295c29d011",
"vout": 0,
"scriptSig": ""
 }
]
[...]
"witness": "<Witness data>"
[...]
```

**警告**

虽然传统的客户端可以处理隔离见证的交易（再次提醒，他们会把这些输出当成人人都可以花的钱），但他们自己没法花这些钱：旧型的钱包可能会尝试用空签名来花用一个隔离见证的输出，但这笔交易在现实中是无效的（更新之后的节点不会允许这样的交易上链）。这就意味着，发送者必须知道接受方的钱包支不支持隔离见证，这样才能为之创建合适类型的输出。



### 4.1.2 Pay-to-Witness-Script-Hash

另一个关键的交易类型是 P2SH。它让交易可以发送给脚本的哈希值（而非公钥的哈希值，也即比特币地址）。要花费 P2SH 交易的输出，花费者需要提供一个脚本（叫做 “赎回脚本”），其哈希值应该与 UTXO 中的脚本哈希值匹配，并基于这个脚本提供 签名/口令/别的东西。这个用法可以把解锁脚本保护起来，让发送者无从知晓一个地址的内容，并且也能节约空间：举个例子，一个多签名钱包的锁定脚本可能非常长，这样我们就必须把整个锁保存起来；有了 P2SH 可以只保存一个哈希值。

假设现在有一个需要提供 5 个私钥中的 2 个的签名才能使用的多签名钱包。如果你使用传统的交易，P2SH 交易输出的锁定脚本将如下：

```
HASH160 54c557e07dde5bb6cb791c7a540e0a4796f5e97e EQUAL
```

要花它的时候，花费的人（也是上一笔交易的接收方）需要提供一个赎回脚本，这个脚本定义了花费条件（多签名，2-5），还有两个签名。所有这些都要放在交易的输入中：

```
[...]
"Vin" : [
"txid": "abcdef12345...",
"vout": 0,
       "scriptSig": "<SigA> <SigB> <2 PubA PubB PubC PubD PubE 5 CHECKMULTISIG>",
]
```

再来看看使用隔离见证后的发送者和接收者。输出的锁定脚本如下：

```
0 9592d601848d04b172905e0ddb0adde59f1590f1e553ffc81ddc4b0ed927dd73
```

就像 P2PKH 交易一样，这个输出的脚本也变得更简单。第一个数值表示版本号，第二个是对应于赎回脚本（witness 程序）的 SHA256 哈希值（32位）。使用这个函数某种意义上是为了用长度来区分 P2WPKH 的见证程序以及 P2WSH 的见证程序（32 字节的 SHA256 哈希值 vs. RIPEMD160(SHA256(script))）。

使用这一输出的交易如下所示：

```
[...]
"Vin" : [
"txid": "abcdef12345...",
"vout": 0,
"scriptSig": "",
]
[...]
"witness": "<SigA> <SigB> <2 PubA PubB PubC PubD PubE 5 CHECKMULTISIG>"
[...]
```

## 4.2 在 P2SH 中嵌入隔离见证

我们已经看到，使用隔离见证是有好处的。不过，上面的例子只对发送者和接收者都有升级软件的情形才适用。但现实并不总是如此。考虑这样一种情形：

Alice 希望给 Bob 转账一些 btc，Bob 有支持隔离见证的钱包软件而她没有。他们显然只能用标准形式的交易，但 Bob 希望使用 SegWit 来减少手续费。

这时候，Bob 可以创建一个包含了 SegWit 脚本的 P2SH 地址、Alice 会把这个地址当成一个普通的 P2SH 地址，因此可以直接向这个地址转账而没有任何问题。但 Bob 可以使用 SegWit 交易来使用这个输出，并获得手续费折扣（下文我们会解释 SegWit 交易的手续费的新的定价方式）。这就是 SegWit 交易的两种类型 P2WSH 和 P2WPKH 在 P2SH 内实现的方式。

### 4.2.1 P2SH(P2WPKH)

想在 P2SH 交易中实现一笔 P2WPKH 交易，Bob 需要使用其公钥创建一个见证程序。然后把结果哈希、转码成一个地址：

```
0 ab68025513c3dbd2f7b92a94e0581f5d50f654e7
```

第一个数值是版本号，而第二个数值是 20 字节的公钥哈希值。这个脚本先做 SHA256 哈希运算，再做 RIPEMD160 运算，就可得到一个 20 字节的哈希值。

这个 P2WPKH 见证程序的 HASH160 结果：

```
3e0547268b3b19288b3adef9719ec8659f4b2b0b
```

转化成一个地址：

```
37Lx99uaGn5avKBxiW26HjedQE3LrDCZru
```

发送给这个地址的输出的锁定脚本，看起来也就跟一个普通的 P2SH 地址的脚本没啥区别：

```
HASH160 3e0547268b3b19288b3adef9719ec8659f4b2b0b EQUAL
```

那么 Bob 花费输出的时候，交易的结构会像这样：

```
[...]
"Vin" : [
 {
"txid": "8adbca5e652c68f8f3c30ac658115bc4af395d0cc7e6beaea18168295c29d011",
"vout": 0,
"scriptSig": "0 ab68025513c3dbd2f7b92a94e0581f5d50f654e7"
 }
]
[...]
"witness": "<Witness data>"
[...]
```

在一开始，我们创建的赎回脚本（也就是那个见证程序）会经过一次哈希计算，如果结果符合锁定脚本中的哈希值，这个脚本就会得到执行，程序会验证放在 witness 字段的签名。

### 4.2.2 P2SH(P2WSH)

P2WSH 脚本也可以用 P2SH 来实现。我们考虑上面所说的 2-5 多签名钱包的例子。所有的步骤都跟 P2SH(P2WPKH) 没什么区别：

首先，创建一个见证程序：

```
0 9592d601848d04b172905e0ddb0adde59f1590f1e553ffc81ddc4b0ed927dd73
```

第一个数值是版本号，第二个数值是 32 位的 SHA256 哈希值，对应于我们的签名脚本。然后我们拿这个见证程序的 HASH160 哈希值转成一个普通的 P2SH 地址。要使用发往这个地址的输出时，我们需在 scriptSig 字段公布这个见证程序，在 witeness 字段提供完整的多签名脚本。

## 4.3 隔离见证的好处

梳理清楚技术的部分之后，我们就可以理解隔离见证的主要优点了。

### 4.3.1 **交易熔融性漏洞**

SegWit 解决的一个关键问题就是比特币交易的 “熔融性”，也即比特币交易的 ID 是哈希值这一点所带来的问题。我们详细说一下。

在以往的比特币交易中，签名是放在交易的输入部分的，第三方可以更改签名且不会让交易失效。这使得第三方可以在完全不更改交易的 “关键” 字段（比如输入、输出、转账的数量）的前提下更改交易的 ID（也就是交易的哈希值）。这样一来，交易还是有效的，含义也还是一样的，但是有了另一个 ID，这可以用来执行另一种攻击，比如 DoS 攻击（拒绝服务式攻击）。
