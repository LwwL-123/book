# 钱包相关原理

加密货币钱包是用来存储用于加密货币交易的公钥和/或私钥的物理设备、程序或服务。除了存储密钥的基本功能之外，加密货币钱包通常还提供加密或签名的功能。例如，签名结果可以执行智能合约、加密货币交易、身份验证或合法签署“文档”等。



# 1. 钱包的分类

### 热钱包、冷钱包

- **冷钱包**（Cold Wallet）：也称**离线钱包**或者**断网钱包**，区块链钱包种类之一，意指网络不能访问到用户私钥的钱包。冷钱包通常依靠“冷”设备（不联网的电脑、手机等）确保比特币私钥的安全，避免了被黑客盗取私钥的风险，但是也可能面临物理安全风险（比如电脑丢失，损坏等）。

- **热钱包**（Hot Wallet）：与冷钱包相对应，也称**在线钱包**或者**联网钱包**（Online Wallet），区块链钱包种类之一。因其联网特性，操作中可能会受到一些病毒或脚本等不安全因素的干扰导致资产处于风险之中，因此安全性比冷钱包低，但比冷钱包更便利。

### 硬件钱包、软件钱包

- 硬件钱包：是冷钱包的一种，指将数字通证资产的私钥单独储存在一个有配置安全芯片的、与互联网隔离的、即连接即用的硬件设备。是所有钱包中安全系数最高的，相对来说最不容易被攻击的钱包

<img src="https://picture-1258612855.cos.ap-shanghai.myqcloud.com/202307031600660.png" alt="image-20230703160019576" style="zoom: 50%;" />

观察钱包本质上是一个观察特定地址链上数据的区块浏览器。 因为硬件钱包不联网，所以并不知道你拥有的资产余额，交易记录等，所以需要观察钱包来观测自己的地址。 因此观察钱包是无法直接进行转账等链上操作的,若需要转账可将私钥或助记词导入钱包或搭配冷钱包授权使用。

- 软件钱包：是一种计算机程序，包括插件钱包、手机钱包等。



# 2. 分层确定性钱包 HD Wallet

分层确定性钱包：常被简写成 HD Wallet，简写来源于 Hierarchical Deterministic Wallet，现在的钱包绝大多数都是HD钱包（Metemask、欧意web3钱包……）

HD 钱包紧密关联的几个 BIP 如下：

- [BIP32](https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki): HD 钱包的核心提案，说明了自私钥生成方法以及树壮结构的构造方式；
- [BIP39](https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki): 提案可以让我们保存一个随机数种子（通常16进制数表示），而不是一堆秘钥
- [BIP44](https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki): 确定支持多链 HD 钱包子私钥派生路径的标准格式；

## 2.1 为什么要使用HD钱包

### 2.1.1 备份更容易

在基本钱包中，每次想要接收一些比特币时，都会独立生成 `private keys` 和 `public keys` 对。

<img src="https://picture-1258612855.cos.ap-shanghai.myqcloud.com/202307031721497.png" alt="image-20230703172148462" style="zoom:50%;" />

传统钱包的问题是一个钱包可能存有一堆密钥地址，每个地址都有一些比特币。这样备份钱包的时候，需要备份所有的密钥。但如果之后生成了一个新地址，你就需要重新备份一次。事实上，每次生成新地址的时候，你都需要做一次备份。 

但使用HD钱包，您可以使用单个种子来创建主私钥，然后可以使用它来生成数十亿个“子” `private keys` 和 `public keys` 。

<img src="https://picture-1258612855.cos.ap-shanghai.myqcloud.com/202307031724358.png" alt="image-20230703172450308" style="zoom:50%;" />

所以现在需要备份的只是种子，因为您从它创建的主私钥将始终以相同的方式（确定性地）生成您的钱包的密钥。

### 2.2.2 权限控制

钱包是分层的，钱包中的每个子密钥还可以生成自己的密钥，这意味着可以创建树结构（或层次结构）来组织钱包中的密钥。

例如，您可以将树的不同部分用于不同的“帐户”。

<img src="https://picture-1258612855.cos.ap-shanghai.myqcloud.com/202307031732658.png" alt="image-20230703173214610" style="zoom:50%;" />

### 2.2.3 独立生成公钥

但主私钥真正酷的地方在于它有一个相应的主公钥，这可以在不知道 `private keys` 的情况下生成相同的子 `public keys` 。

<img src="https://picture-1258612855.cos.ap-shanghai.myqcloud.com/202307031733086.png" alt="image-20230703173337048" style="zoom:50%;" />

因此，可以将主公钥发送到另一台计算机（例如网上商店服务器）以生成新的接收地址，而不必担心如果服务器被黑客攻击，私钥会被盗。

>这对于硬件钱包之类的东西很有用，我们希望将私钥保存在安全设备上，但又希望能够方便地在不同的计算机上生成新地址以接收付款。



## 2.2 HD钱包如何运作？

### 1. BIP39-助记词生成

#### 生成熵

要创建助记符，首先需要生成熵，这是我们随机性的来源。

可以认为熵是一个非常大的随机数，以前没有人生成过，或者将来也不会生成。最好将此数字视为一系列位（例如 `10011010010001...` ），这就是计算机存储数字的方式。

我们生成的熵必须是 32 位的倍数，因为这将允许我们将熵分割成偶数块并稍后转换为单词。此外，熵应该在 128 到 256 位之间，因为这足以使两个人不可能产生相同的熵。

> 注意：始终使用安全的随机数生成器来生成熵。不要使用编程语言的默认“随机”函数，因为它生成的数字对于密码学来说不够随机。 



#### 熵到助记词

现在我们已经得到了熵，我们可以将其编码为单词。首先，我们向熵添加校验和以帮助检测错误（使最终句子更加用户友好）。该校验和是通过 SHA256 对熵进行散列创建的，这为我们的熵提供了唯一的指纹。然后，我们每 32 位熵取该哈希值的 1 位，并将其添加到熵的末尾。

![img](https://picture-1258612855.cos.ap-shanghai.myqcloud.com/202307031819078.png)

接下来，我们将其分成 11 位组，将它们转换为十进制数，并使用这些数字来选择相应的单词。

![img](https://picture-1258612855.cos.ap-shanghai.myqcloud.com/202307031824504.png)

这就是我们的助记句子。

> 提示：单词表中有 2048 个单词。是因为11 位数字可以容纳 0-2047 之间的十进制数。

>通过向每 32 位熵添加 1 位校验和，我们最终将始终得到 33 位的倍数，我们可以将其分成相等的 11 位块。



####  种子助记词

现在我们已经有了助记符句子，我们可以将其转换为最终的种子。

这个过程使用密钥拉伸（Key stretching）函数，被用来增强弱密钥的安全性，PBKDF2是常用的密钥拉伸算法中的一种。
PBKDF2基本原理是通过一个为随机函数(例如 HMAC 函数)，把助记词明文和盐值作为输入参数，然后重复进行运算最终产生生成一个更长的（512 位）密钥种子。这个种子再构建一个确定性钱包并派生出它的密钥。

密钥拉伸函数需要两个参数：助记词和盐。盐可以提高暴力破解的难度。 盐由常量字符串 "mnemonic" 及一个可选的密码组成，注意使用不同密码，则拉伸函数在使用同一个助记词的情况下会产生一个不同的种子，这个过程图示图下:

![img](https://picture-1258612855.cos.ap-shanghai.myqcloud.com/202307041021899.gif)

这个 64 字节结果就是种子，可用于为HD钱包创建主扩展密钥。



#### 验证助记词

助记词包含校验和，这意味着您可以检查给定的助记词是否有效。

为此，您将助记词中的单词转换回位，确定熵部分和校验和部分，并检查从熵创建的校验和是否与助记词中的校验和匹配。

![img](https://picture-1258612855.cos.ap-shanghai.myqcloud.com/202307041026533.png)

> 警告：不要通过随机生成 12-24 个单词来创建助记词。如果您只是从单词列表中随机选择 12-24 个单词，那么您选择的最后一个单词可能不会包含其余单词的正确校验和。因此，当您尝试将其导入钱包时，它可能会告诉您它无效。

### 2. 扩展密钥

扩展密钥是 `private key` 或 `public key` ，可以使用它在分层确定性钱包中派生新密钥。

![img](https://picture-1258612855.cos.ap-shanghai.myqcloud.com/202307041103328.png)

#### 主密钥

第一个扩展密钥（主密钥）是通过将种子放入 HMAC-SHA512 哈希函数来创建的。

<img src="https://picture-1258612855.cos.ap-shanghai.myqcloud.com/202307041107473.png" alt="image-20230704110705423" style="zoom:50%;" />

> 可以将 HMAC 视为哈希函数，它允许您将数据与附加密钥一起传递以生成一组新的随机字节。

HMAC 函数返回 `64 bytes` 数据（这是完全不可预测的）。我们将其分成两半来创建我们的主 `extended private key` ：

- 左半部分是 `private key` ，它就像任何其他私钥一样。
- 右半部分是 `chain code` ，它只是额外的 32 字节随机数据。生成子密钥需要链码。如果掌握了私钥但没有掌握链码，将无法导出后代密钥（从而保护它们）。



 `extended private key` 最终只是一个普通的 `private key` 加上 `chain code` 。

![img](https://picture-1258612855.cos.ap-shanghai.myqcloud.com/202307041112000.png)



我们还可以创建一个相应的 `extended public key` 。这仅涉及获取 `private key` 并计算其相应的 `public key` ，并将其与相同的 `chain code` 耦合。

![img](https://picture-1258612855.cos.ap-shanghai.myqcloud.com/202307041113613.png)

我们有最初的 master `extended private key` 和 master `extended public key` 。



#### Extended Key Tree

所有扩展密钥都可以派生子扩展密钥。

- `extended private keys` 可以使用 `private keys` 和 `public keys` 生成子密钥
- `extended public keys` 只能用 `public keys` 生成子密钥

![img](https://picture-1258612855.cos.ap-shanghai.myqcloud.com/202307041149033.png)

为了安全起见，我们可以从 `extended private key` 派生两种类型的子级：

- **Normal**：`extended private key` 和 `extended public key` 可以生成相同的 `public key` 。
- **Hardened**：只有 `extended private key` 可以生成 `public key` 。

 

#### 子扩展密钥派生

`extended private keys` 和 `extended public keys` 都可以派生子代，每个子代都有自己唯一的 `index` 编号。

派生子密钥有 3 种方法：

- *Normal* Child `extended private key` 
- *Hardened* Child `extended private key`
- *Normal* Child `extended public key` 



##### 1. *Normal* Child `extended private key` 

![img](https://picture-1258612855.cos.ap-shanghai.myqcloud.com/202307051718429.png)

1. 计算出公钥。 （这样，相应的扩展公钥就可以在派生其子项时将相同的数据放入 HMAC 函数中。）
2. 使用 `0` 和 `2147483647` 之间的索引。此范围内的索引指定用于普通子扩展键。
3. **通过 HMAC 将数据和密钥放入。**
   - *data* = `public key`+`index`
   - *key* = `chain code` 

新的 **chain code** 是 HMAC 结果的最后 32 个字节。这只是我们可以用于新链码的一组独特的字节。

新私钥是 HMAC 结果添加到原始私钥的前 32 个字节。这本质上只是将原始私钥增加一个随机的 32 字节数。我们按照曲线的阶数对新私钥进行模运算，以使新私钥保持在椭圆曲线的有效数字范围内。

总而言之，我们使用父扩展私钥（ `public key` + `index` 、 `chain code` ）内的数据并将其通过 HMAC 函数生成一些新的随机字节。我们使用这些新的随机字节从旧的私钥构造下一个私钥。



##### 2. *Hardened* Child `extended private key` 

![img](https://picture-1258612855.cos.ap-shanghai.myqcloud.com/202307051723069.png)

1. 使用 `2147483647` 和 `4294967295` （`2^31-1`到`2^32-1`）之间的索引。此范围内的索引指定用于强化子扩展键。

2. **通过 HMAC 将数据和密钥放入。**
   - *data* = `private key`+`index` (concatenated)
   - *key* = `chain code`

新的chain code是 HMAC 结果的最后 32 个字节。

新私钥是 HMAC 结果添加到原始私钥的前 32 个字节。这同样只是获取原始私钥并将其增加一个随机的 32 字节数。

然而，这个强化子密钥是通过将私钥放入 HMAC 函数（扩展公钥无法访问该函数）来构造的，这意味着以这种方式派生的子扩展私钥将具有无法被访问的公钥。由相应的扩展公钥导出。

##### 3. *Normal* Child `extended public key` 

![img](https://picture-1258612855.cos.ap-shanghai.myqcloud.com/202307051727397.png)

1. 使用 `0` 和 `2147483647` 之间的索引。此范围内的索引指定用于普通子扩展键。
2. **通过 HMAC 将数据和密钥放入。**
   - *data* = `public key`+`index` (concatenated)
   - *key* = `chain code`

新的chain code是 HMAC 结果的最后 32 个字节。这将是与上面的普通子扩展私钥相同的链码，因为如果您回头看，您会发现我们将相同的输入放入 HMAC 函数中。

新的公钥是原始公钥点添加到 HMAC 结果的前 32 个字节作为曲线上的点（椭圆曲线加法）。

##### 4. *Hardened* Child`extended public key`

不存在的派生方式



#### 为什么这样有效？

换句话说，从 `extended public key` 派生的 `public key` 怎么可能对应于从 `extended private key` 派生的 `private key` ？

首先要知道所以在椭圆曲线密码学中， `private key` 只是一个很大的随机整数（小于曲线上的点数），而其对应的 `public key` 只是曲线上的一个点。

```
private key = 112757557418114203588093402336452206775565751179231977388358956335153294300646
public key  = {
    x: 33886286099813419182054595252042348742146950914608322024530631065951421850289, 
    y: 9529752953487881233694078263953407116222499632359298014255097182349749987176
}
```

![img](https://picture-1258612855.cos.ap-shanghai.myqcloud.com/202307051814749.png)

总结一下上述的三种私钥派生规则：

- Hardend Child: extended private key

  - 根私钥—>子私钥—>子公钥—>地址

  - 子私钥 = (父私钥 + HMAC(父私钥+链码+index)) % n
  - hardend模式下，index必须为2^31 - 2^32-1

- Nomal Child: extended private key
  - 根私钥—>子私钥—>子公钥—>地址
  - 子私钥 = (父私钥 + HMAC(父公钥+链码+index)) % n

- Nomal Child: extended public key
  - 根公钥—>子公钥—>地址
  - 子公钥 = 父公钥 + HMAC(父公钥+链码+index)   **（椭圆曲线点加）**



```
父公钥 = G * 父私钥

子私钥 = (父私钥 + HMAC(父公钥+链码+index)) % n
子公钥 = G * （子私钥）= G * ((父私钥 + HMAC(父公钥+链码+index)) % n)
      = G * 父私钥 + G * ((父私钥 + HMAC(父公钥+链码+index)) % n)
      = 父公钥 + G * ((父私钥 + HMAC(父公钥+链码+index)) % n)
```

![img](https://picture-1258612855.cos.ap-shanghai.myqcloud.com/202307051805857.png)



### 3. BIP44 

为了帮助钱包之间的一致性，BIP 44 引入了以下结构：

```
m / purpose' / coin_type' / account' / change / index
```

![img](https://picture-1258612855.cos.ap-shanghai.myqcloud.com/202307051830218.png)

# 3. 拓展阅读

## 3.1 BIP32-EDD25519



