# golang 内存问题排查

## 如何解决

线上出现问题，首先要解决问题，不影响用户使用，后在寻找根因，给出方法

1. 排查项目故障期间，是否有项目发布，如果有，尝试回滚

2. 排查项目故障期间，是否有配置变更，如果有，尝试回滚配置

3. 排查近期项目的代码变更：包括代码、配置是否有变更，如果有，组织review



除此之外，如果问题没有解决

1、排查基础平台&工具侧是否有升级或变更

2、排查依赖方是否有变更（）

3、**重点检查**运营侧是否有管理平台的变更导致影响到了线上业务



## 排查过程

1. 是否存在goroutine逃逸？

查看故障前，goroutine是否有升高现象。

2. 是否代码出现了内存泄露？

通过pprof或coredump的内存快照，进行内存泄漏排查。

3. 其他问题导致的OOM？



## 几个概念

内存溢出 OOM （out of memory），是指程序在申请内存时，没有足够的内存空间供其使用，出现out of memory；比如申请了一个int,但给它存了long才能存下的数，那就是内存溢出。

内存泄露（ memory leak），是指程序在申请内存后，无法释放已申请的内存空间，一次内存泄露危害可以忽略，但内存泄露堆积后果很严重，无论多少内存,迟早会被占光。最终的结果就是导致OOM。

### 1. goroutine逃逸

通常内存泄露的主因就是 goroutine 过多, goroutine过多，内存占用增大。 所以排查问题时，首先看近期的goroutine数量是否增多，什么原因导致gouroutine过多，是否是请求囤积，如何解决



### 2. 代码内存泄漏

#### 2.1 为什么要避免内存泄漏

因为如果变量的内存发生逃逸，它的生命周期就是不可知的，其会被分配到堆上，而堆上分配内存不能像栈一样会自动释放，为了解放程序员双手，专注于业务的实现，go实现了gc垃圾回收机制，但gc会影响程序运行性能，所以要尽量减少程序的gc操作。



#### 2.2 引发内存逃逸的常见情况

1. 在方法内把局部变量指针返回，被外部引用，其生命周期大于栈，则溢出。
2. 发送指针或带有指针的值到channel，因为编译时候无法知道那个goroutine会在channel接受数据，编译器无法知道什么时候释放。
3. 在一个切片上存储指针或带指针的值。比如[]*string，导致切片内容逃逸，其引用值一直在堆上。
4. 因为切片的append导致超出容量，切片重新分配地址，切片背后的存储基于运行时的数据进行扩充，就会在堆上分配。
5. 在interface类型上调用方法，在Interface调用方法是动态调度的，只有在运行时才知道。

