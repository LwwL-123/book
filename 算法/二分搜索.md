# 二分搜索

## 基本的二分搜索

```go
func binary(nums []int,target int) int{

	left := 0
	right := len(nums) - 1

	for left <= right {
		mid := left + (right - left) / 2
		if nums[mid] == target {
			return mid
		}else if nums[mid] < target {
			left = mid + 1
		}else if nums[mid] > target {
			right = mid - 1
		}
	}

	return -1
}
```

## 左侧边界和右侧边界的二分搜索

### [34. 在排序数组中查找元素的第一个和最后一个位置](https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/)



```go
func searchRange(nums []int, target int) []int {

    if len(nums) == 0 {
        return []int{-1,-1}
    }
    l := leftSearch(nums,target)
    r := rightSearch(nums,target)

    return []int{l,r}
}
```

`左边界`

```go
func leftSearch(nums []int,target int) int {
	left := 0
	right := len(nums) - 1

	// 搜索区间为[left,right]
	for left <= right {
		mid := left + (right - left) / 2
		if nums[mid] < target {
			// 区间变为[mid+1,right]
			left = mid + 1
		}else if nums[mid] > target {
			// 区间变为[left,mid-1]
			right = mid - 1
		}else if nums[mid] == target {
			// 收缩右侧边界
			right = mid - 1
		}
	}

	// 因为退出条件为left == right + 1 ,所以当target比nums中所有值都大时,right为最右侧的值,left=right+1,产生越界
	if left >= len(nums) || nums[left] != target {
		return -1
	}

	return left
}
```

`右边界`

```go
func rightSearch(nums []int,target int) int {
	left := 0
	right := len(nums) - 1

	// 搜索区间为[left,right]
	for left <= right {
		mid := left + (right - left) / 2
		if nums[mid] < target {
			// 区间变为[mid+1,right]
			left = mid + 1
		}else if nums[mid] > target {
			// 区间变为[left,mid-1]
			right = mid - 1
		}else if nums[mid] == target {
			// 收缩左侧边界
			left = mid + 1
		}
	}

	// 因为退出条件为left == right + 1 ,所以当target比nums中所有值都小时,mid为0,right=mid-1,产生越界
	if right < 0 || nums[right] != target {
		return -1
	}

	return right
}
```



## [4. 寻找两个正序数组的中位数](https://leetcode-cn.com/problems/median-of-two-sorted-arrays/)

```go
func findMedianSortedArrays(nums1 []int, nums2 []int) float64 {
    length := len(nums1)+len(nums2)
    if length%2 == 1{
        return float64(findKthVal(nums1, nums2, length/2+1))
    }
    k1, k2 := length/2, length/2+1
    return float64(findKthVal(nums1,nums2,k1)+findKthVal(nums1,nums2,k2))/2.0
}

func findKthVal(nums1, nums2 []int,k int) int {
	// 递归的终止条件，如果 nums1 或 nums2 已经被淘汰空了，那就返回剩下那个数组的第 K 即可
	if len(nums1) == 0 {
		return nums2[k-1]
	}

	if len(nums2) == 0 {
		return nums1[k-1]
	}

	// 如果 k 为 1，那就返回 nums1[0] 和 nums2[0] 中最大的
	if k == 1 {
		if nums1[0] <= nums2[0] {
			return nums1[0]
		} else {
			return nums2[0]
		}
	}

	n1, n2 := len(nums1), len(nums2)

	// 淘汰 k/2，但如果有数组不够 k/2，那就淘汰这个数组的全部
	mid1, mid2 := k/2, k/2
	if n1 < k/2 {
		mid1 = n1
	}
	if n2 < k/2 {
		mid2 = n2
	}

	// 淘汰某个数组的 k/2 数据（如果不够就全淘汰）
	if nums1[mid1-1] <= nums2[mid2-1] {
		if mid1 == n1 {
			nums1 = []int{}
		} else {
			nums1 = nums1[mid1:]
		}
		k -= mid1
	} else {
		if mid2 == n2 {
			nums2 = []int{}
		} else {
			nums2 = nums2[mid2:]
		}
		k -= mid2
	}
	
	return findKthVal(nums1, nums2,k)
}

```

