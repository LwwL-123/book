# 回溯

回溯三部曲

- 递归函数参数

- 递归终止条件
- 单层搜索逻辑

```go
func backtracking(参数) {
    if (终止条件) {
        存放结果;
        return;
    }

    for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {
        处理节点;
        backtracking(路径，选择列表); // 递归
        回溯，撤销处理结果 // 比如12后是13，所以要撤销2
    }
}
```



## 子集

#### [78. 子集](https://leetcode-cn.com/problems/subsets/)

```go
var res [][]int

func subsets(nums []int) [][]int {
    // 记录路径
    track := make([]int,0)
    res = [][]int{}

    backtrack(nums,0,track)
    return res
}

func backtrack(nums []int,start int, track []int ) {
    // 递归结束条件，此处无

    // 将路径加入结果集中，注意需要拷贝一份加入，否则后面更改会直接更改结果集
    tmp := make([]int,len(track))
    copy(tmp,track)
    res = append(res,tmp)
    // for循环遍历
    for i:=start; i < len(nums); i++ {
        // 加入
        track = append(track,nums[i])
        // 递归
        backtrack(nums,i+1,track)
        // 撤销
        track = track[:len(track)-1]
    }
}
```



## 组合

#### [77. 组合](https://leetcode-cn.com/problems/combinations/)

```go
var res [][]int
func combine(n int, k int) [][]int {

    res = [][]int{}
    backtrack(n,k,[]int{},1)
    
    return res
}

func backtrack(n,k int,track []int,start int) {
    if len(track) == k {
        tmp := make([]int,len(track))
        copy(tmp,track)
        res = append(res,tmp)
      	return 
    }

    for i:=start; i<=n; i++ {
        track = append(track,i)
        backtrack(n,k,track,i+1)
        track = track[:len(track)-1]
    }
}
```

## 排列

#### [46. 全排列](https://leetcode-cn.com/problems/permutations/)

```go
var res [][]int
var visited map[int]bool
func permute(nums []int) [][]int {
    res = [][]int{}
    visited = make(map[int]bool,len(nums))
    backtrack(nums,[]int{})

    return res
}

func backtrack(nums,trace []int) {
    // 递归结束条件
    if len(trace) == len(nums) {
        tmp := make([]int,len(nums))
        copy(tmp,trace)
        res = append(res,tmp)
    }

    for i:=0; i<len(nums);i++ {
        // 判断这个数字是否使用
        if visited[i] {
            continue
        }
        // 选择
        trace = append(trace,nums[i])
        visited[i] = true
        // 递归
        backtrack(nums,trace)
        // 回溯
        trace = trace[:len(trace)-1]
        visited[i] = false
    }
}
```

