# 回溯

回溯三部曲

- 递归函数参数

- 递归终止条件
- 单层搜索逻辑

```go
func backtracking(参数) {
    if (终止条件) {
        存放结果;
        return;
    }

    for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {
        处理节点;
        backtracking(路径，选择列表); // 递归
        回溯，撤销处理结果 // 比如12后是13，所以要撤销2
    }
}
```



#### [78. 子集](https://leetcode-cn.com/problems/subsets/)

```go
var res [][]int

func subsets(nums []int) [][]int {
    // 记录路径
    track := make([]int,0)
    res = [][]int{}

    backtrack(nums,0,track)
    return res
}

func backtrack(nums []int,start int, track []int ) {
    // 递归结束条件，此处无

    // 将路径加入结果集中，注意需要拷贝一份加入，否则后面更改会直接更改结果集
    tmp := make([]int,len(track))
    copy(tmp,track)
    res = append(res,tmp)
    // for循环遍历
    for i:=start; i < len(nums); i++ {
        // 加入
        track = append(track,nums[i])
        // 递归
        backtrack(nums,i+1,track)
        // 撤销
        track = track[:len(track)-1]
    }
}
```

