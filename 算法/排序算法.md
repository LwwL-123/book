# 排序

## 1. 冒泡

3.从小到大排序
3.1有n个数需要被排序；假设先选取第0个位置的数字和让其和后一位的数进行比较；
3.2如果比较时发现当前数比后一个数大（即比较时，出现不符合我们规则的顺序），
	交换两数；
3.3然后选第1个位置的数字，继续遍历，一轮后，即可找出一个最大数；(即最后一位已经到达其应在位置；)
	最后一个数已经不需要参与后面的比较了；
3.4继续遍历，则每轮比较后，最后一个数就会到达其应到位置；
3.5每轮能找出一个最大的数，则最多仅需n-1轮即可全部排序完成；因为其余数排序好后，
	最后一个数不用在找自己的位置了；（i表示外层for循环表示轮数）
3.6每轮选中的数下标为j,从0开始；
	因为选中的数和后一个比较，最后一个不用选中，所以j的上限 -1；
	又因为每过1轮，最后一个数就会被定下来，所以每轮j的上限 -i;

```go
	
for i:=0;i< len(intArr)-1;i++{
		for j:=0;j< len(intArr)-1-i;j++{

			if intArr[j+1] < intArr[j]{
				temp := intArr[j+1]
				intArr[j+1] = intArr[j]
				intArr[j] =temp
			}

		}
		fmt.Printf("第%v轮冒泡排序后：%v\n",i+1,intArr)
		
	}
```



## 2. 快排

```go
func main() {
   s := []int{6,3,2,62,4,51}
   qSort(s)
   fmt.Println(s)
}
func qSort(s []int){
    len := len(s)
    if len < 2 {
        return
    }
    head,trip := 0, len-1
    value := s[head]
    for head < trip { //s[head]就是我们的标尺，
        if s[head+1] > value { //标尺元素遇到大于它的，就把这个元素丢到最右边trip
            s[head+1],s[trip] = s[trip],s[head+1]
            trip--
        }else if s[head+1] < s[head]{ //标尺元素遇到小于它的，就换位置，标尺右移动一位。
            s[head],s[head+1] = s[head+1],s[head]
            head++
        }else{ //相等不用交换
            head++
        }
    }
    //进过上面的处理，保证了标尺左边的元素都小于等于标尺元素（s[head]），右边的元素大于等于标尺元素。
    qSort(s[:head])
    qSort(s[head+1:])
}
```

根据代码我们知道，每一层的递归操作次数为该次递归所传入的元素个数，忽略每次减去的枢轴（1个元素并没有给到下一层，但是每层这里减掉一个常数对复杂度的分析影响不大，所以暂时忽略），即：

第1层是n次，

第2层有2次递归，每次n/2次，共n次操作，

第3层有4次递归，每次n/4次，共n次操作，

……

（最后一层）第k层有k次递归，每次n/2^(k-1)次，共n次操作

由于递归结束的条件是只有一个元素，所以这里的n/2^(k-1)=1   =>   k=logn+1 

即递归树的深度为logn

时间复杂度=每层的操作次数*树的深度=nlogn 即：O(nlgn);



#### [215. 数组中的第K个最大元素](https://leetcode-cn.com/problems/kth-largest-element-in-an-array/)

```go
func findKthLargest(nums []int, k int) int {
    left, right := 0, len(nums) - 1
    for left < right {
        if nums[left] < nums[left+1] {
            nums[left],nums[left+1] = nums[left+1],nums[left]
            left++
        }else if nums[left] > nums[left+1]{
            nums[left+1],nums[right] = nums[right],nums[left+1]
            right--
        }else {
            left++
        }

    }


    if left == k - 1 {
        return nums[left]
    }else if left < k - 1{
        return findKthLargest(nums[left+1:],k-left-1)
    }else {
        return findKthLargest(nums[:left],k)
    }

}
```

```go
import "container/heap"
import "fmt"

type minHeap []int
func findKthLargest(nums []int, k int) int {
    m := &minHeap{}
    heap.Init(m)
    
    for i := 0; i < len(nums); i++ {
        if i < k {
            heap.Push(m,nums[i])
        }else {
            if nums[i] > (*m)[0] {
                heap.Pop(m)
                heap.Push(m,nums[i])
            }
        }
    }

    return (*m)[0]
}

func (h minHeap) Len() int { return len(h) }
func (h minHeap) Less(i,j int) bool { return h[i] < h[j] }
func (h minHeap) Swap(i,j int) { h[i],h[j] = h[j],h[i] }
func (h *minHeap) Push(i interface{}) {
    *h = append(*h,i.(int))
}
func (h *minHeap) Pop() interface{} {
    old := *h
    x := old[len(old)-1]
    old = old[:len(old)-1]
    *h = old
    return x
}
```





## 3. 堆排序

动态查找中位数

```go
package main

import (
	"container/heap"
	"fmt"
)

type initHeap struct {
	heap []int
	// true大根堆 false小根堆
	bool
}
func main() {
	min := &initHeap{[]int{},false}
	max := &initHeap{[]int{},true}
	heap.Init(min)
	heap.Init(max)
	for {
		var tmp int
		fmt.Scan(&tmp)
		insert(min,max,tmp)
		fmt.Println(max)
		fmt.Println(min)
		fmt.Println(getM(min,max,tmp))
	}
}

func getM(min,max *initHeap,i int) int {
	if max.Len() == min.Len() {
		return (min.heap[0] + max.heap[0]) /2
	}else {
		return max.heap[0]
	}
}

func insert(min,max *initHeap,i int) {
	if min.Len() == 0 && max.Len() == 0 {
		heap.Push(max,i)
	}else if min.Len() == max.Len() {// 如果大根堆小根堆长度相等，则必须要插入大根堆
		if i > min.heap[0] {
			heap.Push(max,heap.Pop(min))
			heap.Push(min,i)
		}else {
			heap.Push(max,i)
		}
	}else {
		if i < max.heap[0] {
			heap.Push(min,heap.Pop(max))
			heap.Push(max,i)
		}else {
			heap.Push(min,i)
		}
	}
}

func (h initHeap) Len() int{ return len(h.heap) }
func (h initHeap) Less(i, j int) bool {
	if h.bool {
		return h.heap[i] > h.heap[j]
	}else {
		return h.heap[i] < h.heap[j]
	}
}
func (h initHeap) Swap(i, j int) { h.heap[i],h.heap[j] = h.heap[j],h.heap[i] }
func (h *initHeap) Push(x interface{}) { h.heap = append(h.heap, x.(int)) }
func (h *initHeap) Pop() interface{} {
	old := *h
	l := len(old.heap)
	x := old.heap[l-1]
	h.heap = old.heap[:l-1]
	return x
}
```





# 稳定性

   就是能保证排序前2个相等的数其在序列的前后位置顺序和排序后它们两个的前后位置顺序相同。

   稳定性的好处。排序算法如果是稳定的，那么从一个键上排序，然后再从另一个键上排序，第一个键排序的结果可以为第二个键排序所用。基数排序就是这样，先按低位排序，逐次按高位排序，低位相同的元素其顺序再高位也相同时是不会改变的。



- **不稳定: 选择排序、快速排序、希尔排序、堆排序**

- **稳定: 冒泡排序、插入排序、归并排序和基数排序**

![这里写图片描述](https://picture-1258612855.cos.ap-shanghai.myqcloud.com/20220325170513.png)



# topk

求k个最大的数：维护一个大小为 K 的小顶堆，依次将数据放入堆中，当堆的大小满了的时候，只需要将堆顶元素与下一个数比较：如果大于堆顶元素，则将当前的堆顶元素抛弃，并将该元素插入堆中。遍历完全部数据，Top K 的元素也自然都在堆里面了。

当然，如果是求前 K 个最小的数，只需要改为大顶堆即可



面对海量数据，我们就可以放分布式的方向去思考了

我们可以将数据分散在多台机器中，然后每台机器并行计算各自的 TopK 数据，最后汇总，再计算得到最终的 TopK 数据
