## 1. tcp 和 udp 的区别?

1. TCP面向连接(如打电话要先拨号建立连接);UDP是无连接的，即发送数据之前不需要建立连接
2. TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达; UDP尽最大努力交付，即不保证可靠交付
   - 举例：tcp：聊天室，udp：打微信电话
3. TCP面向字节流，实际上是TCP把数据看成一连串无结构的字节流;   UDP是面向报文的，UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低
4. 每一条TCP连接只能是点到点的;UDP支持一对一，一对多，多对一和多对多的交互通信
5. TCP首部开销20字节;UDP的首部开销小，只有8个字节
6. TCP的逻辑通信信道是全双工的可靠信道，UDP则是不可靠信道



## 2. 双工通信

1. 单工数据传输只支持数据在一个方向上传输
2. 半双工数据传输允许数据在两个方向上传输，但是，在某一时刻，只允许数据在一个方向上传输，它实际上是一种切换方向的单工通信；
3. 全双工数据通信允许数据同时在两个方向上传输，因此，**全双工通信是两个单工通信方式的结合，它要求发送设备和接收设备都有独立的接收和发送能力。**



## 3. HTTP 与 HTTPS 的区别

|   区别   |                             HTTP                             |                            HTTPS                             |
| :------: | :----------------------------------------------------------: | :----------------------------------------------------------: |
|   协议   | 运行在 TCP 之上，明文传输，**客户端与服务器端都无法验证对方的身份** | 身披 SSL( Secure Socket Layer )外壳的 HTTP，运行于 SSL 上，SSL 运行于 TCP 之上， **是添加了加密和认证机制的 HTTP**。 |
|   端口   |                              80                              |                             443                              |
| 资源消耗 |                             较少                             |         由于加解密处理，会消耗更多的 CPU 和内存资源          |
|   开销   |                           无需证书                           |            需要证书，而证书一般需要向认证机构购买            |
| 加密机制 |                              无                              |         共享密钥加密和公开密钥加密并用的混合加密机制         |
|  安全性  |                              弱                              |                    由于加密机制，安全性强                    |



## 4. 对称加密与非对称加密

对称密钥加密是指加密和解密使用同一个密钥的方式，这种方式存在的最大问题就是密钥发送问题，即如何安全地将密钥发给对方；而非对称加密是指使用一对非对称密钥，即公钥和私钥，公钥可以随意发布，但私钥只有自己知道。发送密文的一方使用对方的公钥进行加密处理，对方接收到加密信息后，使用自己的私钥进行解密。

由于非对称加密的方式不需要发送用来解密的私钥，所以可以保证安全性；但是和对称加密比起来，它非常的慢，所以我们还是要用对称加密来传送消息，但对称加密所使用的密钥我们可以通过非对称加密的方式发送出去。



## 5. TCP 协议如何来保证传输的可靠性

答：TCP 提供一种面向连接的、可靠的字节流服务。其中，面向连接意味着两个使用 TCP 的应用（通常是一个客户和一个服务器）在彼此交换数据之前必须先建立一个 TCP 连接。在一个 TCP 连接中，仅有两方进行彼此通信；而字节流服务意味着两个应用程序通过 TCP 链接交换 8 bit 字节构成的字节流，TCP 不在字节流中插入记录标识符。

**对于可靠性，TCP通过以下方式进行保证：**

- **数据包校验**：目的是检测数据在传输过程中的任何变化，若校验出包有错，则丢弃报文段并且不给出响应，这时TCP发送数据端超时后会重发数据；
- **对失序数据包重排序**：既然TCP报文段作为IP数据报来传输，而IP数据报的到达可能会失序，因此TCP报文段的到达也可能会失序。TCP将对失序数据进行重新排序，然后才交给应用层；
- **丢弃重复数据**：对于重复数据，能够丢弃重复数据；
- **应答机制**：当TCP收到发自TCP连接另一端的数据，它将发送一个确认。这个确认不是立即发送，通常将推迟几分之一秒；
- **超时重发**：当TCP发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段；
- **流量控制**：TCP连接的每一方都有固定大小的缓冲空间。TCP的接收端只允许另一端发送接收端缓冲区所能接纳的数据，这可以防止较快主机致使较慢主机的缓冲区溢出，这就是流量控制。TCP使用的流量控制协议是可变大小的滑动窗口协议。



## 6. TCP/IP 通信传输流

![图片](https://gitee.com/lzw657434763/pictures/raw/master/Blog/20211019103925)

发送端在层与层之间传输数据时，每经过一层必定会加上一个该层的首部信息。反之，接收端在层与层之间传输数据时，每经过一层会把相关的首部信息去掉。





## 7. DNS 域名解析

当你在浏览器的地址栏输入 `https://www.cnblogs.com` 后会发生什么

![图片](https://gitee.com/lzw657434763/pictures/raw/master/Blog/20211019104014)

1. 由域名→IP地址 寻找IP地址的过程依次经过了浏览器缓存、系统缓存、hosts文件、路由器缓存、 递归搜索根域名服务器。
2. 建立TCP/IP连接（三次握手具体过程）
3. 由浏览器发送一个HTTP请求
4. 经过路由器的转发，通过服务器的防火墙，该HTTP请求到达了服务器
5. 服务器处理该HTTP请求，返回一个HTML文件
6. 浏览器解析该HTML文件，并且显示在浏览器端
7. 这里需要注意：

- HTTP协议是一种基于TCP/IP的应用层协议，进行HTTP数据请求必须先建立TCP/IP连接
- 可以这样理解：HTTP是轿车，提供了封装或者显示数据的具体形式；Socket是发动机，提供了网络通信的能力。
- 两个计算机之间的交流无非是两个端口之间的数据通信,具体的数据会以什么样的形式展现是以不同的应用层协议来定义的。



## 8. 客户端不断进行请求链接会怎样？

DDos(Distributed Denial of Service)攻击？

答：服务器端会为每个请求创建一个链接，并向其发送确认报文，然后等待客户端进行确认

**(1). DDos 攻击：**

- 客户端向服务端发送请求链接数据包
- 服务端向客户端发送确认数据包
- 客户端不向服务端发送确认数据包，服务器一直等待来自客户端的确认

**(2). DDos 预防：（没有彻底根治的办法，除非不使用TCP）**

- 限制同时打开SYN半链接的数目
- 缩短SYN半链接的Time out 时间
- 关闭不必要的服务





## 9.GET 与 POST 的区别？

GET与POST是我们常用的两种HTTP Method，二者之间的区别主要包括如下五个方面：

(1). 从功能上讲，GET一般用来从服务器上获取资源，POST一般用来更新服务器上的资源；（Restful标准）

(2). 从RESTFUL角度上说，GET是幂等的，即读取同一个资源，总是得到相同的数据，而POST不是幂等的，因为每次请求对资源的改变并不是相同的；进一步地，GET不会改变服务器上的资源，而POST会对服务器资源进行改变；

(3). 从请求参数形式上看，GET请求的数据会附在URL之后，即将请求数据放置在HTTP报文的请求头 中，以?分割URL和传输数据，参数之间以&相连。特别地，如果数据是英文字母/数字，原样发送；否则，会将其编码为 application/x-www-form-urlencoded MIME 字符串(如果是空格，转换为+，如果是中文/其他字符，则直接把字符串用BASE64加密，得出如：%E4%BD%A0%E5%A5%BD，其中％XX中的XX为该符号以16进制表示的ASCII)；而POST请求会把提交的数据则放置在是HTTP请求报文的请求体中。

(4). 就安全性而言，POST的安全性要比GET的安全性高，因为GET请求提交的数据将明文出现在URL上，而且POST请求参数则被包装到请求体中，相对更安全。

(5). 从请求的大小看，GET请求的长度受限于浏览器或服务器对URL长度的限制，允许发送的数据量比较小，而POST请求则是没有大小限制的。



**为什么在GET请求中会对URL进行编码？**

我们知道，在GET请求中会对URL中非西文字符进行编码，这样做的目的就是为了 **避免歧义**。



## 10. 什么是 HTTP 协议无状态协议？怎么解决Http协议无状态协议?

答：HTTP 是一个无状态的协议，也就是没有记忆力，这意味着每一次的请求都是独立的，缺少状态意味着如果后续处理需要前面的信息，则它必须要重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就很快

HTTP 的这种特性有优点也有缺点：

- **优点**：解放了服务器，每一次的请求“点到为止”，不会造成不必要的连接占用
- **缺点**：每次请求会传输大量重复的内容信息，并且，在请求之间无法实现数据的共享



解决方案：

1. 使用参数传递机制：
   将参数拼接在请求的 URL 后面，实现数据的传递（GET方式），例如：`/param/list?username=wmyskxz`
   **问题**：可以解决数据共享的问题，但是这种方式一不安全，二数据允许传输量只有1kb
2. 使用 Cookie 技术
3. 使用 Session 技术



## 11. Session、Cookie 与 Application

答：Cookie和Session都是客户端与服务器之间保持状态的解决方案，具体来说，cookie机制采用的是在客户端保持状态的方案，而session机制采用的是在服务器端保持状态的方案。

**(1). Cookie  ：**

Cookie实际上是一小段的文本信息。客户端请求服务器，如果服务器需要记录该用户状态，就使用response向客户端浏览器颁发一个Cookie，而客户端浏览器会把Cookie保存起来。当浏览器再请求该网站时，浏览器把请求的网址连同该Cookie一同提交给服务器，服务器检查该Cookie，以此来辨认用户状态。服务器还可以根据需要修改Cookie的内容。

**(2). Session ：**

同样地，会话状态也可以保存在服务器端。客户端请求服务器，如果服务器记录该用户状态，就获取Session来保存状态，这时，如果服务器已经为此客户端创建过session，服务器就按照sessionid把这个session检索出来使用；如果客户端请求不包含sessionid，则为此客户端创建一个session并且生成一个与此session相关联的sessionid，并将这个sessionid在本次响应中返回给客户端保存。保存这个sessionid的方式可以采用 **cookie机制** ，这样在交互过程中浏览器可以自动的按照规则把这个标识发挥给服务器；若浏览器禁用Cookie的话，可以通过 **URL重写机制** 将sessionid传回服务器。

**(3). Session 与 Cookie 的对比：**

- **实现机制**：Session的实现常常依赖于Cookie机制，通过Cookie机制回传SessionID；
- **大小限制**：Cookie有大小限制并且浏览器对每个站点也有cookie的个数限制，Session没有大小限制，理论上只与服务器的内存大小有关；
- **安全性**：Cookie存在安全隐患，通过拦截或本地文件找得到cookie后可以进行攻击，而Session由于保存在服务器端，相对更加安全；

- **服务器资源消耗**：Session是保存在服务器端上会存在一段时间才会消失，如果session过多会增加服务器的压力。



Application（ServletContext）：与一个Web应用程序相对应，为应用程序提供了一个全局的状态，所有客户都可以使用该状态。



## 12. 常用的HTTP方法有哪些？

- GET：用于请求访问已经被URI（统一资源标识符）识别的资源，可以通过URL传参给服务器
- POST：用于传输信息给服务器，主要功能与GET方法类似，但一般推荐使用POST方式。
- PUT：传输文件，报文主体中包含文件内容，保存到对应URI位置。
- HEAD：获得报文首部，与GET方法类似，只是不返回报文主体，一般用于验证URI是否有效。
- DELETE：删除文件，与PUT方法相反，删除对应URI位置的文件。
- OPTIONS：查询相应URI支持的HTTP方法。



## 13. 常见HTTP状态码

答：

1. 1xx（临时响应）
2. 2xx（成功）
3. 3xx（重定向）：表示要完成请求需要进一步操作
4. 4xx（错误）：表示请求可能出错，妨碍了服务器的处理
5. 5xx（服务器错误）：表示服务器在尝试处理请求时发生内部错误
6. 常见状态码：

- 200（成功）
- 304（未修改）：自从上次请求后，请求的网页未修改过。服务器返回此响应时，不会返回网页内容
- 401（未授权）：请求要求身份验证
- 403（禁止）：服务器拒绝请求
- 404（未找到）：服务器找不到请求的网页



## 14. SQL 注入

答：SQL注入就是通过把SQL命令插入到Web表单提交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意的SQL命令。

**(1).SQL注入攻击的总体思路：**

1. 寻找到SQL注入的位置
2. 判断服务器类型和后台数据库类型
3. 针对不通的服务器和数据库特点进行SQL注入攻击

**(2). SQL注入攻击实例：**

比如，在一个登录界面，要求输入用户名和密码，可以这样输入实现免帐号登录：

```
用户名： ‘or 1 = 1 --
密 码：
```

用户一旦点击登录，如若没有做特殊处理，那么这个非法用户就很得意的登陆进去了。这是为什么呢?下面我们分析一下：从理论上说，后台认证程序中会有如下的SQL语句：

```
String sql = “select * from user_table where username=’ “+userName+” ’ and password=’ “+password+” ‘”;
```

因此，当输入了上面的用户名和密码，上面的SQL语句变成：

```
SELECT * FROM user_table WHERE username=’’or 1 = 1 – and password=’’
```

分析上述SQL语句我们知道，username=‘ or 1=1 这个语句一定会成功；然后后面加两个-，这意味着注释，它将后面的语句注释，让他们不起作用。这样，上述语句永远都能正确执行，用户轻易骗过系统，获取合法身份。

**(3). 应对方法：**

1.参数绑定：

使用预编译手段，绑定参数是最好的防SQL注入的方法。目前许多的ORM框架及JDBC等都实现了SQL预编译和参数绑定功能，攻击者的恶意SQL会被当做SQL的参数而不是SQL命令被执行。在mybatis的mapper文件中，对于传递的参数我们一般是使用#和

2.使用正则表达式过滤传入的参数
