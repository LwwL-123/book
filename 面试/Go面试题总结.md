### 1. Golang空结构体作用

答：节省内存

1. map。
   value是空结构体，构造集合。

2. 通道。
   只传递信号，不传递数据。

3. 切片。
   不管切片多长，都不会占用空间。

4. 仅包含方法的结构体。
   不用指针，节约空间。

5. 最后零字段。
   final zero field：结构体里的最后一个属性如果是空结构体，会当成1个字节处理。如果结构体嵌套的全是空结构体，还是0个字节。



### 2. golang map 判断key是否存在

```go
if _, ok := map[key]; ok {
    // 存在
}
 
if _, ok := map[key]; !ok {
    // 不存在
}
```



### 3. 各包init的执行顺序

- 如果一个包导入了其他包，则首先初始化导入的包。
- 然后初始化当前包的常量。
- 接下来初始化当前包的变量。
- 最后，调用当前包的 init() 函数。

![在这里插入图片描述](https://gitee.com/lzw657434763/pictures/raw/master/Blog/20211223163615.png)

```
import --> const --> var --> init()
```

- 一个包可以有多个 init 函数 (在单个文件中或分布在多个文件中)，并且按照它们呈现给编译器的顺序被调用。

- 一个包将只初始化一次，即使它是从多个包导入的。



###  4. 垃圾回收时，写代码的时候如何减少小对象分配 

小对象在堆上频繁地申请释放，会造成内存碎片（有的叫空洞），导致分配大的对象时无法申请到连续的内存空间，一般建议是采用内存池。Go runtime底层也采用内存池，但每个span大小为4k，同时维护一个cache。cache有一个0到n的list数组，list数组的每个单元挂载的是一个链表，链表的每个节点就是一块可用的内存，同一链表中的所有节点内存块都是大小相等的；但是不同链表的内存大小是不等的，也就是说list数组的一个单元存储的是一类固定大小的内存块，不同单元里存储的内存块大小是不等的。这就说明cache缓存的是不同类大小的内存对象，当然想申请的内存大小最接近于哪类缓存内存块时，就分配哪类内存块。当cache不够再向spanalloc中分配。

建议：小对象合并成结构体一次分配，示意如下：

```go
for k, v := range m {
    k, v := k, v // copy for capturing by the goroutine
    go func() {
        // using k & v
    }()
}
```



替换为：

```go
for k, v := range m {
    x := struct {k , v string} {k, v} // copy for capturing by the goroutine
    go func() {
        // using x.k & x.v
    }()
}
```



### 5. []byte与string转换

GO里面的string类型是一个不可变类型，不像c++中std:string，可以直接char*取值转化，指向同一地址内容；而GO中[]byte与string底层两个不同的结构，他们之间的转换存在实实在在的值对象拷贝，所以尽量减少这种不必要的转化

建议：存在字符串拼接等处理，尽量采用[]byte，例如：

```go
func Prefix(b []byte) []byte {
    return append([]byte("hello", b...))
}
```



字符串的拼接优先考虑bytes.Buffer

由于string类型是一个不可变类型，但拼接会创建新的string。GO中字符串拼接常见有如下几种方式：

- string + 操作 ：导致多次对象的分配与值拷贝
- fmt.Sprintf ：会动态解析参数，效率好不哪去
- strings.Join ：内部是[]byte的append
- bytes.Buffer ：可以预先分配大小，减少对象分配与拷贝

建议：对于高性能要求，优先考虑bytes.Buffer，预先分配大小。非关键路径，视简洁使用。fmt.Sprintf可以简化不同类型转换与拼接。



### 6. 协程和线程和进程的区别？

- 进程: 进程是具有一定独立功能的程序，进程是系统资源分配和调度的最小单位。每个进程都有自己的独立内存空间，不同进程通过进程间通信来通信。由于进程比较重量，占据独立的内存，所以上下文进程间的切换开销（栈、寄存器、虚拟内存、文件句柄等）比较大，但相对比较稳定安全。

- 线程: 线程是进程的一个实体,线程是内核态,而且是CPU调度和分派的基本单位,它是比进程更小的能独立运行的基本单位。线程间通信主要通过共享内存，上下文切换很快，资源开销较少，但相比进程不够稳定容易丢失数据。

- 协程: 协程是一种用户态的轻量级线程，协程的调度完全是由用户来控制的。协程拥有自己的寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈，直接操作栈则基本没有内核切换的开销，可以不加锁的访问全局变量，所以上下文的切换非常快。



### 7. Goroutine和线程的区别？

- 一个线程可以有多个协程
- 线程、进程都是同步机制，而协程是异步
- 协程可以保留上一次调用时的状态，当过程重入时，相当于进入了上一次的调用状态
- 协程是需要线程来承载运行的，所以协程并不能取代线程，「线程是被分割的CPU资源，协程是组织好的代码流程」

