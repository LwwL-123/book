# 面试系统

## 1. 什么是虚拟内存

一开始都是单任务模式，一个进程直接操作物理内存，但后来发展到多任务模式，一个系统中，通常存在多个进程，如果直接操作物理内存，就很容易出现修改到其他进程的内存情况，甚至会覆盖操作系统所使用的的内存，所以出现了保护模式，即进程不直接使用物理内存，而是使用一个对应的虚拟内存，操作系统负责把虚拟内存映射到物理内存。

例如，在32位系统下，会把物理内存以`4k(2^12)`为一页，从虚拟内存到物理内存，是以页为单位映射的。然后操作系统会以链表的形式存储各个进程的控制信息，在windows系统中为pcb控制块，在linux系统中为一个task_struct结构体。每个进程的控制信息中，会有一个指针，指向当前进程的页表。



如果是一级页表,那么4G的内存，每个内存页的大小为4kb，则需要`4GB/4KB = 2^20` 1M个页表项，即页表（每个进程都有一个页表）占用4MB（`1M*4B=4MB`)的内存空间。一级页表管理地址空间如下

```
20 | 12 
```

32位内存，用前20位标识一个唯一的页表项，后12位则用来记录物理页的业内偏移地址，刚好2^12=4kb



但是通常linux为了节约内存，采取二级页表的模式也就是，每一个一级页表还对应一个二级页表，二级页表管理地址空间如下

```
10 | 10 | 12 
```

前十位用来标记1024个一级页表，中间十位用来标记二级页表，后12位一样是物理内存的页内偏移地址，一共用的空间为 `1k*4B+1k*1k*4B=4MB+4KB`，这样算下来其实还比一级页表多了4kb的空间，那么为什么会采用二级页表呢。

其实是因为，对于大多数进程来说，使用到的内存空间远为到达4GB，对于一级页表来说，必须要覆盖全部的虚拟地址空间，而对于二级页表来说，我们的二级页表无需创建，只在需要的时候在进行创建二级页表，这样就比只有一级页表必须要使用4M的空间，节省到了4K的空间加上要使用的二级页表，并且1024个第二级页表中，只会有很少的一部分在某一时刻正在使用，我们岂不是可以把二级页表都放在磁盘中，在需要时才调入到内存。

![image-20220121141027599](https://gitee.com/lzw657434763/pictures/raw/master/Blog/20220121141027.png)

除此之外，页表还有一个特殊功能，首先我们知道一个物理内存页是4kb，所以他一定是4kb的整数位，所以页表项对应的线性地址，低12位一定全是0，所以这12位我们可以用来存储其他的信息，比如内存页是否可读，可写，可执行等，其中最后一位用来标识该物理内存页是否已经映射。

这是因为进程向操作系统申请内存时，OS不会立马分配，只会先记录下来，等到进程访问这段内存空间时，才会映射到真正的物理内存，所以内存的虚拟地址空间，只是他可以使用的一个范围，只有真正被映射到物理内存，才算是能够合法使用的虚拟内存，而没有使用的部分，要使用就必须先进行映射。



而线性地址到物理地址的转换，会交给cpu当中的内存管理单元（MMU）来负责，当前页目录的物理地址，会被保存到一个特定的寄存器中，这样CPU就可以借助页目录和页表，把线性地址转换为物理地址了，此外由于频繁查页表会影响效率，CPU会把已经查询过的页表，缓存到快表(TLB)中，需要的时候，先去TLB查找，没有的话再去查页表，最后写入TLB

![image-20220121142032129](https://gitee.com/lzw657434763/pictures/raw/master/Blog/20220121142032.png)

如果要切换到另一个进程，那么存储的寄存器页目录也会改变，之前的TLB缓存会失效，需要全部重新查询页表，这也是进程切换代价高的一个原因。如果cpu查页表时发现，对应的物理页还没有完成映射，就会发生缺页，那么就会去查询是否申请，如果已经申请，就实际分配物理页面并完成页表映射