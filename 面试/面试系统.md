# 面试系统

## 1. 什么是虚拟内存

一开始都是单任务模式，一个进程直接操作物理内存，但后来发展到多任务模式，一个系统中，通常存在多个进程，如果直接操作物理内存，就很容易出现修改到其他进程的内存情况，甚至会覆盖操作系统所使用的的内存，所以出现了保护模式，即进程不直接使用物理内存，而是使用一个对应的虚拟内存，操作系统负责把虚拟内存映射到物理内存。

例如，在32位系统下，会把物理内存以`4k(2^12)`为一页，从虚拟内存到物理内存，是以页为单位映射的。然后操作系统会以链表的形式存储各个进程的控制信息，在windows系统中为pcb控制块，在linux系统中为一个task_struct结构体。每个进程的控制信息中，会有一个指针，指向当前进程的页表。



如果是一级页表,那么4G的内存，每个内存页的大小为4kb，则需要`4GB/4KB = 2^20` 1M个页表项，即页表（每个进程都有一个页表）占用4MB（`1M*4B=4MB`)的内存空间。一级页表管理地址空间如下

```
20 | 12 
```

32位内存，用前20位标识一个唯一的页表项，后12位则用来记录物理页的业内偏移地址，刚好2^12=4kb



但是通常linux为了节约内存，采取二级页表的模式也就是，每一个一级页表还对应一个二级页表，二级页表管理地址空间如下

```
10 | 10 | 12 
```

前十位用来标记1024个一级页表，中间十位用来标记二级页表，后12位一样是物理内存的页内偏移地址，一共用的空间为 `1k*4B+1k*1k*4B=4MB+4KB`，这样算下来其实还比一级页表多了4kb的空间，那么为什么会采用二级页表呢。

其实是因为，对于大多数进程来说，使用到的内存空间远为到达4GB，对于一级页表来说，必须要覆盖全部的虚拟地址空间，而对于二级页表来说，我们的二级页表无需创建，只在需要的时候在进行创建二级页表，这样就比只有一级页表必须要使用4M的空间，节省到了4K的空间加上要使用的二级页表，并且1024个第二级页表中，只会有很少的一部分在某一时刻正在使用，我们岂不是可以把二级页表都放在磁盘中，在需要时才调入到内存。

![image-20220121141027599](https://gitee.com/lzw657434763/pictures/raw/master/Blog/20220121141027.png)

除此之外，页表还有一个特殊功能，首先我们知道一个物理内存页是4kb，所以他一定是4kb的整数位，所以页表项对应的线性地址，低12位一定全是0，所以这12位我们可以用来存储其他的信息，比如内存页是否可读，可写，可执行等，其中最后一位用来标识该物理内存页是否已经映射。

这是因为进程向操作系统申请内存时，OS不会立马分配，只会先记录下来，等到进程访问这段内存空间时，才会映射到真正的物理内存，所以内存的虚拟地址空间，只是他可以使用的一个范围，只有真正被映射到物理内存，才算是能够合法使用的虚拟内存，而没有使用的部分，要使用就必须先进行映射。



而线性地址到物理地址的转换，会交给cpu当中的内存管理单元（MMU）来负责，当前页目录的物理地址，会被保存到一个特定的寄存器中，这样CPU就可以借助页目录和页表，把线性地址转换为物理地址了，此外由于频繁查页表会影响效率，CPU会把已经查询过的页表，缓存到快表(TLB)中，需要的时候，先去TLB查找，没有的话再去查页表，最后写入TLB

![image-20220121142032129](https://gitee.com/lzw657434763/pictures/raw/master/Blog/20220121142032.png)

如果要切换到另一个进程，那么存储的寄存器页目录也会改变，之前的TLB缓存会失效，需要全部重新查询页表，这也是进程切换代价高的一个原因。如果cpu查页表时发现，对应的物理页还没有完成映射，就会发生缺页，那么就会去查询是否申请，如果已经申请，就实际分配物理页面并完成页表映射。



最后，虚拟内存其实会被分为内核空间和用户空间，所有用户会共享1G的内核空间，这也是进程间共享的一种方式。



## 2. 进程和线程

我们编写的代码只是一个存储在硬盘的静态文件，通过编译后就会生成二进制可执行文件，当我们运行这个可执行文件后，它会被装载到内存中，接着 CPU 会执行程序中的每一条指令，那么这个**运行中的程序，就被称为「进程」**。

在早期的操作系统中，只有进程，没有线程， 随着技术发展，在执行一些细小任务时，本身无需分配单独资源时，也只能创建进程来执行，但是进程切换开销很大，而且进程间通信共享数据也很麻烦，所以就提出了线程的概念。



同一个进程内多个线程之间共享相同的地址空间，就可以共享代码段、数据段、打开的文件等资源，但每个线程都有独立一套的寄存器和栈，可以看到线程执行时，CPU操作的是线程的栈帧，面向的是某个线程，所以才说线程是独立调度的最小单位，进程是资源分配的最小单位

<img src="https://gitee.com/lzw657434763/pictures/raw/master/Blog/20220121153100.png" alt="image-20220121153100602" style="zoom:50%;" />





在虚拟内存中，虚拟内存为了保障安全，把虚拟内存分为两部分，内核空间和用户空间，内核空间由所有用户共享，而用户空间不能直接访问内核空间。操作系统保存的进程控制信息PCB就保存在内核空间，PCB中保存有页表，进程ID，父进程ID，状态，句柄表等等，而相同状态的PCB会由链表的形式存储在内核中。

线程就是进程的执行体，他要有执行入口，通常是某个函数的指令入口，线程执行时，要使用操作系统从进程虚拟地址空间中分配的栈空间来存储数据，也就是线程栈。



在创建线程时，操作系统会在用户空间和内核空间分配两段栈，即用户栈和内核栈，线程切换到内核态执行时，会使用内核栈，为了是不允许用户代码对其进行修改以保证安全。操作系统会记录每个线程的控制信息，例如`执行入口，线程栈，线程ID等`，在Windows中线程控制信息对应TCB，可以在PCB中找到进程拥有的线程列表，同一个进程内的线程会共享进程地址空间和句柄表等资源。而在Linux中，只用了一个task_struct结构体，进程创建子进程时会指定他和自己使用同一套地址空间和句柄表的资源，用这种方法实现多线程的效果

<img src="https://gitee.com/lzw657434763/pictures/raw/master/Blog/20220121175035.png" alt="image-20220121175035090" style="zoom:50%;" />

### 进程有哪些状态



<img src="https://gitee.com/lzw657434763/pictures/raw/master/Blog/20220121220648.png" alt="image-20220121220648358" style="zoom:67%;" />

假如进程死锁，那么死锁的进程，都会在阻塞状态，等待资源的释放

另外，还有一个状态叫**挂起状态**，它表示进程没有占有物理内存空间。这跟阻塞状态是不一样，阻塞状态是等待某个事件的返回。

由于虚拟内存管理原因，进程的所使用的空间可能并没有映射到物理内存，而是在硬盘上，这时进程就会出现挂起状态，另外调用 sleep 也会被挂起。

<img src="https://gitee.com/lzw657434763/pictures/raw/master/Blog/20220121220641.png" alt="image-20220121220641026" style="zoom:67%;" />

### 进程控制块PCB

> PCB 具体包含什么信息呢？

**进程描述信息：**

- 进程标识符：标识各个进程，每个进程都有一个并且唯一的标识符；
- 用户标识符：进程归属的用户，用户标识符主要为共享和保护服务；

**进程控制和管理信息：**

- 进程当前状态，如 new、ready、running、waiting 或 blocked 等；
- 进程优先级：进程抢占 CPU 时的优先级；

**资源分配清单：**

- 有关内存地址空间或虚拟地址空间的信息，比如**页表的起始地址**，所打开文件的列表和所使用的 I/O 设备信息。

**CPU 相关信息：**

- CPU 中各个寄存器的值，当进程被切换时，CPU 的状态信息都会被保存在相应的 PCB 中，以便进程重新执行时，能从断点处继续执行。



PCB在内存中的存储方式是以链表方式存储：

![image-20220121220635140](https://gitee.com/lzw657434763/pictures/raw/master/Blog/20220121220635.png)

### 用户态-》内核态

线程中发生函数调用就是在线程栈中分配函数调用栈，而虚拟内存分配，文件操作，网络读写等很多功能都是由操作系统来完成的，再向用户程序暴露接口。所以线程免不了要“系统调用”，CPU中会有一个特权标志，用于记录当前程序是执行在用户态还是内核态，只有标记为内核态才可以访问内核空间。如果线程处于用户态，就不能访问内核空间，所以系统调用发生时，就得切换到内核态，使用线程的内核栈，执行内核空间的系统函数

<img src="https://gitee.com/lzw657434763/pictures/raw/master/Blog/20220121192725.png" alt="image-20220121192724814" style="zoom:50%;" />

这就是从``用户态``切换到``内核态``。

最初系统调用是通过软中断触发的，就是通过指令模拟中断。在OS中，会有一张中断向量表，用来吧各个中断编号映射到相应的处理程序，例如在linux系统中，系统调用中断对应的编号为0x80，对应的系统程序，就是用来派发系统调用的。在硬件层面，CPU有一个中断控制器，负责接收中断信号，切换到内核态，保存用户态执行现场。一部分寄存器的值会通过硬件保存起来，还有一部分通用寄存器的值，会被压入内核栈中。等系统调用结束后，再利用之前保存的信息，恢复线程在用户态的执行现场，继续执行后面的指令，即完成的一次系统调用。

![image-20220121201347884](https://gitee.com/lzw657434763/pictures/raw/master/Blog/20220121201348.png)



### 上下文切换

现代操作系统中，CPU的执行权被分为不同的时间片，只有获得CPU时间片的程序才能运行，由于时间片很短，所以用户感觉不到程序切换的过程。一个线程CPU时间用完时，CPU硬件时钟会触发一次时钟中断，对应的中断处理程序，会从已经就绪的线程中，挑选一个来执行

<img src="https://gitee.com/lzw657434763/pictures/raw/master/Blog/20220121205405.png" alt="image-20220121205405539" style="zoom: 67%;" />



如果现在要将线程A1切换到A2，而这两个线程同属于线程A，那么就只需要将线程A1的执行现场保存起来，后续再把指令指针，栈指针这些寄存器的值修改为线程A2的信息。当A1重新获得时间片时，会根据切换前保存在栈的信息，恢复到切换前的执行现场，继续完成他的任务

<img src="https://gitee.com/lzw657434763/pictures/raw/master/Blog/20220121210340.png" alt="image-20220121210340514" style="zoom:50%;" />

但如果现在线程A1要切换到另一个进程的线程B1，除了线程切换外，还要切换进程。首先CPU保存的页表需要切换到进程B，所以进程切换和线程切换的区别是，进程切换会导致地址空间等进程资源发生变化，还会导致TLB缓存失效，代价会更大



**进程的上下文切换不仅包含了虚拟内存、栈、全局变量等用户空间的资源，还包括了内核堆栈、寄存器等内核空间的资源**

**当两个线程是属于同一个进程，因为虚拟内存是共享的，所以在切换时，虚拟内存这些资源就保持不动，只需要切换线程的私有数据、寄存器等不共享的数据**

### 软中断和硬中断

- 软中断是执行中断指令产生的，而硬中断是由外设引发的。
- 硬中断的中断号是由中断控制器提供的，软中断的中断号由指令直接指出，无需使用中断控制器。
- 硬中断是可屏蔽的，软中断不可屏蔽。
- 硬中断处理程序要确保它能快速地完成任务，这样程序执行时才不会等待较长时间，称为上半部。
- 软中断处理硬中断未完成的工作，是一种推后执行的机制，属于下半部。

软终端有：时钟中断，系统中断



### 内核线程和用户线程(协程)

我们知道线程是进程中的执行体，拥有一个执行入口，以及从进程虚拟空间中分配的栈，包括用户栈和内核栈，操作系统会记录线程控制信息，而线程获得时间片以后才可以执行，CPU
