# 面试系统



## 2. 进程和线程

我们编写的代码只是一个存储在硬盘的静态文件，通过编译后就会生成二进制可执行文件，当我们运行这个可执行文件后，它会被装载到内存中，接着 CPU 会执行程序中的每一条指令，那么这个**运行中的程序，就被称为「进程」**。

在早期的操作系统中，只有进程，没有线程， 随着技术发展，在执行一些细小任务时，本身无需分配单独资源时，也只能创建进程来执行，但是进程切换开销很大，而且进程间通信共享数据也很麻烦，所以就提出了线程的概念。



同一个进程内多个线程之间共享相同的地址空间，就可以共享代码段、数据段、打开的文件等资源，但每个线程都有独立一套的寄存器和栈，可以看到线程执行时，CPU操作的是线程的栈帧，面向的是某个线程，所以才说线程是独立调度的最小单位，进程是资源分配的最小单位

<img src="https://gitee.com/lzw657434763/pictures/raw/master/Blog/20220121153100.png" alt="image-20220121153100602" style="zoom:50%;" />





在虚拟内存中，虚拟内存为了保障安全，把虚拟内存分为两部分，内核空间和用户空间，内核空间由所有用户共享，而用户空间不能直接访问内核空间。操作系统保存的进程控制信息PCB就保存在内核空间，PCB中保存有页表，进程ID，父进程ID，状态，句柄表等等，而相同状态的PCB会由链表的形式存储在内核中。

线程就是进程的执行体，他要有执行入口，通常是某个函数的指令入口，线程执行时，要使用操作系统从进程虚拟地址空间中分配的栈空间来存储数据，也就是线程栈。



在创建线程时，操作系统会在用户空间和内核空间分配两段栈，即用户栈和内核栈，线程切换到内核态执行时，会使用内核栈，为了是不允许用户代码对其进行修改以保证安全。操作系统会记录每个线程的控制信息，例如`执行入口，线程栈，线程ID等`，在Windows中线程控制信息对应TCB，可以在PCB中找到进程拥有的线程列表，同一个进程内的线程会共享进程地址空间和句柄表等资源。而在Linux中，只用了一个task_struct结构体，进程创建子进程时会指定他和自己使用同一套地址空间和句柄表的资源，用这种方法实现多线程的效果

<img src="https://gitee.com/lzw657434763/pictures/raw/master/Blog/20220121175035.png" alt="image-20220121175035090" style="zoom:50%;" />

### 进程有哪些状态



<img src="https://gitee.com/lzw657434763/pictures/raw/master/Blog/20220121220648.png" alt="image-20220121220648358" style="zoom:67%;" />

假如进程死锁，那么死锁的进程，都会在阻塞状态，等待资源的释放

另外，还有一个状态叫**挂起状态**，它表示进程没有占有物理内存空间。这跟阻塞状态是不一样，阻塞状态是等待某个事件的返回。

由于虚拟内存管理原因，进程的所使用的空间可能并没有映射到物理内存，而是在硬盘上，这时进程就会出现挂起状态，另外调用 sleep 也会被挂起。

<img src="https://gitee.com/lzw657434763/pictures/raw/master/Blog/20220121220641.png" alt="image-20220121220641026" style="zoom:67%;" />

### 进程控制块PCB

> PCB 具体包含什么信息呢？

**进程描述信息：**

- 进程标识符：标识各个进程，每个进程都有一个并且唯一的标识符；
- 用户标识符：进程归属的用户，用户标识符主要为共享和保护服务；

**进程控制和管理信息：**

- 进程当前状态，如 new、ready、running、waiting 或 blocked 等；
- 进程优先级：进程抢占 CPU 时的优先级；

**资源分配清单：**

- 有关内存地址空间或虚拟地址空间的信息，比如**页表的起始地址**，所打开文件的列表和所使用的 I/O 设备信息。

**CPU 相关信息：**

- CPU 中各个寄存器的值，当进程被切换时，CPU 的状态信息都会被保存在相应的 PCB 中，以便进程重新执行时，能从断点处继续执行。



PCB在内存中的存储方式是以链表方式存储：

![image-20220121220635140](https://gitee.com/lzw657434763/pictures/raw/master/Blog/20220121220635.png)

### 用户态-》内核态

线程中发生函数调用就是在线程栈中分配函数调用栈，而虚拟内存分配，文件操作，网络读写等很多功能都是由操作系统来完成的，再向用户程序暴露接口。所以线程免不了要“系统调用”，CPU中会有一个特权标志，用于记录当前程序是执行在用户态还是内核态，只有标记为内核态才可以访问内核空间。如果线程处于用户态，就不能访问内核空间，所以系统调用发生时，就得切换到内核态，使用线程的内核栈，执行内核空间的系统函数

<img src="https://gitee.com/lzw657434763/pictures/raw/master/Blog/20220121192725.png" alt="image-20220121192724814" style="zoom:50%;" />

这就是从``用户态``切换到``内核态``。

最初系统调用是通过软中断触发的，就是通过指令模拟中断。在OS中，会有一张中断向量表，用来吧各个中断编号映射到相应的处理程序，例如在linux系统中，系统调用中断对应的编号为0x80，对应的系统程序，就是用来派发系统调用的。在硬件层面，CPU有一个中断控制器，负责接收中断信号，切换到内核态，保存用户态执行现场。一部分寄存器的值会通过硬件保存起来，还有一部分通用寄存器的值，会被压入内核栈中。等系统调用结束后，再利用之前保存的信息，恢复线程在用户态的执行现场，继续执行后面的指令，即完成的一次系统调用。

![image-20220121201347884](https://gitee.com/lzw657434763/pictures/raw/master/Blog/20220121201348.png)



### 上下文切换

现代操作系统中，CPU的执行权被分为不同的时间片，只有获得CPU时间片的程序才能运行，由于时间片很短，所以用户感觉不到程序切换的过程。一个线程CPU时间用完时，CPU硬件时钟会触发一次时钟中断，对应的中断处理程序，会从已经就绪的线程中，挑选一个来执行

<img src="https://gitee.com/lzw657434763/pictures/raw/master/Blog/20220121205405.png" alt="image-20220121205405539" style="zoom: 67%;" />



如果现在要将线程A1切换到A2，而这两个线程同属于线程A，那么就只需要将线程A1的执行现场保存起来，后续再把指令指针，栈指针这些寄存器的值修改为线程A2的信息。当A1重新获得时间片时，会根据切换前保存在栈的信息，恢复到切换前的执行现场，继续完成他的任务

<img src="https://gitee.com/lzw657434763/pictures/raw/master/Blog/20220121210340.png" alt="image-20220121210340514" style="zoom:50%;" />

但如果现在线程A1要切换到另一个进程的线程B1，除了线程切换外，还要切换进程。首先CPU保存的页表需要切换到进程B，所以进程切换和线程切换的区别是，进程切换会导致地址空间等进程资源发生变化，还会导致TLB缓存失效，代价会更大



**进程的上下文切换不仅包含了虚拟内存、栈、全局变量等用户空间的资源，还包括了内核堆栈、寄存器等内核空间的资源**

**当两个线程是属于同一个进程，因为虚拟内存是共享的，所以在切换时，虚拟内存这些资源就保持不动，只需要切换线程的私有数据、寄存器等不共享的数据**

### 软中断和硬中断

- 软中断是执行中断指令产生的，而硬中断是由外设引发的。
- 硬中断的中断号是由中断控制器提供的，软中断的中断号由指令直接指出，无需使用中断控制器。
- 硬中断是可屏蔽的，软中断不可屏蔽。
- 硬中断处理程序要确保它能快速地完成任务，这样程序执行时才不会等待较长时间，称为上半部。
- 软中断处理硬中断未完成的工作，是一种推后执行的机制，属于下半部。

软终端有：时钟中断，系统中断



### 内核线程和用户线程(协程)

我们知道线程是进程中的执行体，拥有一个执行入口，以及从进程虚拟空间中分配的栈，包括用户栈和内核栈，操作系统会记录线程控制信息，而线程获得时间片以后才可以执行，CPU这里栈指针，指令指针等寄存器都要切换到对应的线程。

那么如果线程自己又创建几个执行体，给他们指定各自的执行入口，申请一些内存给他们作为执行栈，那么线程就可以按需调度这几个执行体了，为了实现这些执行体的切换，线程也需要记录他们的控制信息，其中包括id,栈的位置，执行入口地址，执行现场等等。

线程可以选择一个来执行，此时CPU中指令指针就会指向这个执行体的执行入口，栈帧和栈指针寄存器也会指向线程给他们分配的执行栈。要切换执行体时，要保存当前执行体中的执行现场，然后切换到另一个执行体，通过同样的方式，可以恢复到之前的执行体，这些由线程创建的执行体也就是所谓的协程，因为用户程序不能操作内核空间，所以只能给协程分配用户栈，而OS对协程一无所知，所以又叫做用户态线程

![image-20220122221620184](https://gitee.com/lzw657434763/pictures/raw/master/Blog/20220122221620.png)



### 调度

进程都希望自己能够占用 CPU 进行工作，那么这涉及到前面说过的进程上下文切换。那到底什么时候调度进程，或以什么原则来调度进程呢？

#### 1.调度时机

在进程的生命周期中，当进程从一个运行状态到另外一状态变化的时候，其实会触发一次调度。

比如，以下状态的变化都会触发操作系统的调度：

- *从就绪态 -> 运行态*：当进程被创建时，会进入到就绪队列，操作系统会从就绪队列选择一个进程运行；
- *从运行态 -> 阻塞态*：当进程发生 I/O 事件而阻塞时，操作系统必须另外一个进程运行；
- *从运行态 -> 结束态*：当进程退出结束后，操作系统得从就绪队列选择另外一个进程运行；

因为，这些状态变化的时候，操作系统需要考虑是否要让新的进程给 CPU 运行，或者是否让当前进程从 CPU 上退出来而换另一个进程运行。
