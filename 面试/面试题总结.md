# OS

## 1. 进程与线程的区别

在早期的操作系统中，只有进程，没有线程， 随着技术发展，在执行一些细小任务时，本身无需分配单独资源时，也只能创建进程来执行，但是进程切换开销很大，而且进程间通信共享数据也很麻烦，所以就提出了线程的概念。

一个进程独享一块虚拟内存，线程就是在进程的虚拟内存中分配一套独立的栈和寄存器，CPU操作的是线程的栈帧，所以线程是调度的基本单位，而共享进程的虚拟内存空间，所以进程是资源分配的基本单位。

在linux系统中，实际上没有线程的概念，只用了一个task_struct结构体，进程创建子进程时会指定他和自己使用同一套地址空间和句柄表的资源，用这种方法实现多线程的效果。而在windows系统中，进程对应一个PCB进程控制块，而线程使用TCB记录的



## 2.进程和线程间的通信方式

进程：

- 匿名管道，命名管道（见[进程与线程](http://47.116.70.98:8081/Linux/Linux%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B.html)，观看管道原理详解）
- 消息队列
- 共享内存
- 信号
- socket

线程：**因为同一进程的不同线程共享同一份全局内存区域，其中包括初始化数据段、未初始化数据段，以及堆内存段，所以线程之间可以方便、快速地共享信息。只需要将数据复制到共享（全局或堆）变量中即可。**不过，要避免出现多个线程试图同时修改同一份信息，通常使用：

- 互斥锁
- 信号量



## 3. 线程、协程的区别

先讲解一下虚拟内存分为内核空间和用户空间，所有的系统操作，都得由用户发起系统中断，转而在内核空间中完成。线程可以说是内核级线程，而协程则是由线程创建，操作系统无法调度，由线程自己调度，自己分配空间，但只能在用户空间中，不能涉及内核空间。



## 4. 常见的进程调度算法

先来先服务，短作业优先，高响应比优先，时间片轮转



## 5. 进程线程的状态

因为线程是CPU调度的基本单位，而在Linux系统中，其实没有线程和进程的概念的区分，所以他们的状态都是：

- 创建，就绪，运行，阻塞，结束
- 创建，就绪，就绪挂起，运行，阻塞，阻塞挂起，结束



## 6. 僵尸进程和孤儿进程

`僵尸进程`（Z僵死状态（zombie））：当一个子进程结束运行（一般是调用exit、运行时发生致命错误或收到终止信号所导致）时，子进程的退出状态（返回值）会回报给操作系统，系统则以SIGCHLD信号将子进程被结束的事件告知父进程，此时子进程的进程控制块（PCB）仍驻留在内存中。一般来说，收到SIGCHLD后，父进程会使用wait系统调用以获取子进程的退出状态，然后内核就可以从内存中释放已结束的子进程的PCB；而如若父进程没有这么做的话，子进程的PCB就会一直驻留在内存中，也即成为僵尸进程

其实，僵尸进程是有危害的。进程的退出状态必须被维持下去，因为它要告诉关心它的进程（父进程），你交给我的任务，我办的怎么样了。可父进程如果一直不读取，那子进程就一直处于Z状态。维护退出状态本身就是要用数据维护，也属于进程基本信息，所以保存在task_struct(PCB)中，换句话说，当一个进程一直处于Z状态，那么它的PCB也就一直都要被维护。因为PCB本身就是一个结构体会占用空间，僵尸进程也就会造成资源浪费，所以我们应该避免僵尸进程的产生

想要解决僵尸进程也很简单，直接找到父进程杀掉，那么僵尸进程将会被init进程接管，并回收

`孤儿进程`：孤儿进程则是指当一个父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程。孤儿进程将被init进程(进程号为1)所收养，并由init进程对它们完成状态收集工作。

孤儿进程由于有init进程循环的wait()回收资源，因此并没有什么危害



## 7. 管道的底层实现原理

创建管道会返回两个描述符，管道的读取端描述符 `fd[0]`，另一个是管道的写入端描述符 `fd[1]`

匿名管道是特殊的文件，只存在于内存，不存于文件系统中。也就是内核空间里面的一段缓存，通过父子进程共享文件描述符，来进行管道通信。

而对于命名管道，也就是创建了一个管道文件，只要在进程中读取这个文件，就可以达到通信的目的



## 8. 线程和进程的上下文切换

`同一个进程的线程上下文切换`: 只需要将线程的执行现场保存起来，就是栈帧，指令指针，寄存器等。再把

指令指针，栈指针这些寄存器的值修改为新线程的信息。

`不同进程的线程上下文切换`：如果是不同进程间的切换，就要涉及到进程的切换。首先CPU保存的页表需要切换到进程B，所以进程切换和线程切换的区别是，进程切换会导致地址空间等进程资源发生变化，还会导致TLB缓存失效，代价会更大。**进程的上下文切换不仅包含了虚拟内存、栈、全局变量等用户空间的资源，还包括了内核堆栈、寄存器等内核空间的资源**



## 9. 虚拟内存

可以从为什么会有虚拟内存，虚拟内存如何映射到物理内存，一级页表和二级页表的区别，二级页表为什么省空间，线性地址后12位多余字段的作用，虚拟内存的空间分配

详见： [虚拟内存](http://47.116.70.98:8081/Linux/Linux%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98.html)



## 10. 内存泄漏和内存溢出

- 内存溢出**（Out Of Memory）**：申请内存时，没有足够的空间

- 内存泄漏**（Memory Leak）**：申请了内存，但没有释放，导致空间浪费

  - 也就是向系统申请分配内存进行使用(new)，可是使用完了以后却不归还(delete)，结果你申请到的那块内存你自己也不能再访问（也许你把它的地址给弄丢了），而系统也不能再次将它分配给需要的程序。

  

也就是内存泄漏最终会导致内存溢出



## 11. 页面置换算法

当 CPU 访问的页面不在物理内存时，便会产生一个缺页中断，请求操作系统将所缺页调入到物理内存。

- 最佳页面置换算法（OPT）
  - **置换在「未来」最长时间不访问的页面**
- 先进先出置换算法（FIFO）
  - **选择在内存驻留时间很长的页面进行中置换**
- 最近最久未使用的置换算法（LRU）
  - **选择最长时间没有被访问的页面进行置换**
- 最不常用置换算法（LFU）
  - **选择「访问次数」最少的那个页面，并将其淘汰**



## 12. 用户态内核态切换

线程中发生函数调用就是在线程栈中分配函数调用栈，而虚拟内存分配，文件操作，网络读写等很多功能都是由操作系统来完成的，再向用户程序暴露接口。所以线程免不了要“系统调用”，CPU中会有一个特权标志，用于记录当前程序是执行在用户态还是内核态，只有标记为内核态才可以访问内核空间。如果线程处于用户态，就不能访问内核空间，所以系统调用发生时，就得切换到内核态，使用线程的内核栈，执行内核空间的系统函数

最初系统调用是通过软中断触发的，就是通过指令模拟中断。在OS中，会有一张中断向量表，用来吧各个中断编号映射到相应的处理程序，例如在linux系统中，系统调用中断对应的编号为0x80，对应的系统程序，就是用来派发系统调用的。在硬件层面，CPU有一个中断控制器，负责接收中断信号，切换到内核态，保存用户态执行现场。一部分寄存器的值会通过硬件保存起来，还有一部分通用寄存器的值，会被压入内核栈中。等系统调用结束后，再利用之前保存的信息，恢复线程在用户态的执行现场，继续执行后面的指令，即完成的一次系统调用。

后改为特殊指令触发系统调用，如sysenter，syscall，当cpu执行到这些指令时，就会陷入内核态，从专用的寄存器拿到派发入口的地址，省去了查询中断向量表的过程。



## 13. 软中断和硬中断

- 软中断是执行中断指令产生的，而硬中断是由外设引发的。
- 硬中断的中断号是由中断控制器提供的，软中断的中断号由指令直接指出，无需使用中断控制器。
- 硬中断是可屏蔽的，软中断不可屏蔽。

为了避免由于中断处理程序执行时间过长，而影响正常进程的调度，Linux 将中断处理程序分为上半部和下半部：

- 上半部，对应硬中断，由硬件触发中断，用来快速处理中断；
- 下半部，对应软中断，由内核触发中断，用来异步处理上半部未完成的工作；

软终端有：网络收发、定时、调度、RCU 锁等各种类型,可以通过查看 /proc/softirqs 来观察软中断的累计中断次数情况



# Mysql

## 1. B- 树与 B+ 树的区别

- #### 单点查询

B+ 树只有叶子节点才会存放数据，B树所有节点都存放数据，所以B-树在最好的情况下可能达到O(1)，但波动较大。B+树的非叶子节点可以存放更多的索引，因此 B+ 树可以比 B 树更「矮胖」，查询底层节点的磁盘 I/O次数会更少

- #### 插入和删除效率

B+ 树有大量的冗余节点，这样使得删除一个节点的时候，可以直接从叶子节点中删除，甚至可以不动非叶子节点，这样删除非常快。B 树则不同，B 树没有冗余节点，删除节点的时候非常复杂，比如删除根节点中的数据，可能涉及复杂的树的变形。

- #### 范围查询

B+ 树所有叶子节点间还有一个链表进行连接，这种设计对范围查找非常有帮助。B 树没有将所有叶子节点用链表串联起来的结构，因此只能通过树的遍历来完成范围查询，这会涉及多个节点的磁盘 I/O 操作，范围查询效率不如 B+ 树



## 2. 为什么用B+树，不用二叉树、B树和红黑树

要设计一个 MySQL 的索引数据结构，不仅仅考虑数据结构增删改的时间复杂度，更重要的是要考虑磁盘 I/0 的操作次数。因为索引和记录都是存放在硬盘，硬盘是一个非常慢的存储设备，我们在查询数据的时候，最好能在尽可能少的磁盘 I/0 的操作次数内完成。



二分查找树虽然是一个天然的二分结构，能很好的利用二分查找快速定位数据，但是每当插入的元素都是树内最大的元素，就会导致二分查找树退化成一个链表，此时查询复杂度就会从 O(logn)降低为 O(n)。

为了解决二分查找树退化成链表的问题，就出现了自平衡二叉树，保证了查询操作的时间复杂度就会一直维持在 O(logn) 。但是它本质上还是一个二叉树，每个节点只能有 2 个子节点，随着元素的增多，树的高度会越来越高。

而树的高度决定于磁盘  I/O 操作的次数，因为树是存储在磁盘中的，访问每个节点，都对应一次磁盘 I/O 操作，也就是说树的高度就等于每次查询数据时磁盘 IO 操作的次数，所以树的高度越高，就会影响查询性能。



B 树和 B+ 都是通过多叉树的方式，会将树的高度变矮，所以这两个数据结构非常适合检索存于磁盘中的数据。

但是 MySQL 默认的存储引擎 InnoDB 采用的是 B+ 作为索引的数据结构，原因有：

- B+树非叶子结点不存放数据，相比存储即存索引又存记录的 B 树，B+树的非叶子节点可以存放更多的索引，因此 B+ 树可以比 B 树更「矮胖」，查询底层节点的磁盘 I/O次数会更少。

- B+ 树有大量的冗余节点（所有非叶子节点都是冗余索引），这些冗余索引让 B+ 树在插入、删除的效率都更高，比如删除根节点的时候，不会像 B 树那样会发生复杂的树的变化；
- B+ 树叶子节点之间用链表连接了起来，有利于范围查询，而 B 树要实现范围查询，因此只能通过树的遍历来完成范围查询，这会涉及多个节点的磁盘 I/O 操作，范围查询效率不如 B+ 树。



而红黑树基本都是存储在内存中才会使用的数据结构。在大规模数据存储的时候，红黑树往往出现由于树的深度过大而造成磁盘IO读写过于频繁，进而导致效率低下的情况。磁盘IO代价主要花费在查找所需的柱面上，树的深度过大会造成磁盘IO频繁读写。根据磁盘查找存取的次数往往由树的高度所决定，所以，只要我们通过某种较好的树结构减少树的结构尽量减少树的高度，B树可以有多个子女，从几十到上千，可以降低树的高度。



## 3. 事务的特性

ACID：原子性，一致性，隔离性，持久性

- 原子性、持久性：通过 redo log （重做日志）来保证的
- 一致性：通过 undo log（回滚日志） 来保证的
- 隔离性：通过 MVCC（多版本并发控制） 或锁机制来保证的



## 4. 执行事务会引发的问题

- 脏读：**如果一个事务「读到」了另一个「未提交事务修改过的数据」，就意味着发生了「脏读」现象。**
- 不可重复度：**在一个事务内多次读取同一个数据，如果出现前后两次读到的数据不一样的情况，就意味着发生了「不可重复读」现象。**
- 幻读：**在一个事务内多次查询某个符合查询条件的「记录数量」，如果出现前后两次查询到的记录数量不一样的情况，就意味着发生了「幻读」现象。**

## 5. 事务的隔离级别、如何实现

- **读未提交（\*read uncommitted\*）**，指一个事务还没提交时，它做的变更就能被其他事务看到；
- **读提交（\*read committed\*）**，指一个事务提交之后，它做的变更才能被其他事务看到；
- **可重复读（\*repeatable read\*）**，指一个事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的，**MySQL InnoDB 引擎的默认隔离级别**；
- **串行化（\*serializable\* ）**；会对记录加上读写锁，在多个事务对这条记录进行读写操作时，如果发生了读写冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行；
- ![image-20220221131841259](https://gitee.com/lzw657434763/pictures/raw/master/Blog/20220221131841.png)



这四种隔离级别具体是如何实现的呢？

### 5.1 读未提交

对于「读未提交」隔离级别的事务来说，因为可以读到未提交事务修改的数据，所以直接读取最新的数据就好了；

### 5.2 串行化

对于「串行化」隔离级别的事务来说，通过加读写锁的方式来避免并行访问；

### 5.3. 可重复读

「可重复读」隔离级别是启动事务时生成一个 Read View，然后整个事务期间都在用这个 Read View。

Read View的四个字段：

- creator_trx_id ：指的是**创建该 Read View 的事务的事务 id**
- m_ids ：指的是创建 Read View 时当前数据库中**活跃且未提交的事务的事务 id 列表**，注意是一个列表。
- min_trx_id ：指的是创建 Read View 时当前数据库中**活跃且未提交的事务中最小事务的事务 id**，也就是 m_ids 的最小值。
- max_trx_id ：创建 Read View 时当前数据库中应该给下一个事务的 id 值**；



同时我们还需要了解聚族索引记录中的两个隐藏列，对于使用 InnoDB 存储引擎的数据库表，它的聚族索引记录中都包含下面两个隐藏列：

- trx_id，当一个事务对某条聚族索引记录进行改动时，就会**把该事务的事务 id 记录在 trx_id 隐藏列里**；
- roll_pointer，每次对某条聚族索引记录进行改动时，都会把旧版本的记录写入到 undo 日志中，然后**这个隐藏列是个指针，指向每一个旧版本记录**，于是就可以通过它找到修改前的记录。



「可重复读」隔离级别就是在启动时创建了 Read View，然后在事务期间读取数据的时候，在找到数据后，先会将该记录的 trx_id 和该事务的 Read View 里的字段做个比较：

- 如果记录的 trx_id 比该事务的 Read View 中的 creator_trx_id 要小，且不在 m_ids 列表里，这意味着这条记录的事务早就在该事务前提交过了，所以该记录对该事务可见；
- 如果记录的 trx_id 比该事务的 Read View 中的 creator_trx_id 要大，且在 m_ids 列表里，这意味着该事务读到的是和自己同时启动的另外一个事务修改的数据，这时就不应该读取这条记录，而是沿着 undo log 链条往下找旧版本的记录，直到找到 trx_id 等于或者小于该事务 id 的第一条记录。

**这种通过记录的版本链来控制并发事务访问同一个记录时的行为，这就叫 MVCC（多版本并发控制）。**



### 5.4 读已提交

对于「读提交」和「可重复读」隔离级别的事务来说，它们是通过 **Read View **来实现的，它们的区别在于创建 Read View 的时机不同：

- 「读提交」隔离级别是在每个 select 都会生成一个新的 Read View，也意味着，事务期间的多次读取同一条数据，前后两次读的数据可能会出现不一致，因为可能这期间另外一个事务修改了该记录，并提交了事务。
- 「可重复读」隔离级别是启动事务时生成一个 Read View，然后整个事务期间都在用这个 Read View，这样就保证了在事务期间读到的数据都是事务启动前的记录。



## 6. Mysql死锁

**Innodb 引擎为了解决「可重复读」隔离级别下的幻读问题，就引出了 next-key 锁**，它是记录锁和间隙锁的组合。

- Record Loc，记录锁，锁的是记录本身；
- Gap Lock，间隙锁，锁的就是两个值之间的空隙，以防止其他事务在这个空隙间插入新的数据，从而避免幻读现象。



next-key lock 锁的是索引，而不是数据本身，所以如果 update 语句的 where 条件没有用到索引列，那么就会全表扫描，在一行行扫描的过程中，不仅给行加上了行锁，还给行两边的空隙也加上了间隙锁，相当于锁住整个表，然后直到事务结束才会释放锁。



事务 A 和事务 B 在执行完后 `select ... for update` 语句后都持有范围为`(1006,+∞）`的间隙锁，而接下来的插入操作为了获取到插入意向锁，都在等待对方事务的间隙锁释放，于是就造成了循环等待，导致死锁。

![image-20220221183627514](https://gitee.com/lzw657434763/pictures/raw/master/Blog/20220221183627.png)

# 网络/基础

## 1. **OSI七层、五层模型，每一层的作用**

OSI七层模型：

- 物理层：主要定义物理设备标准，它的主要作用是传输比特流，这一层的数据叫做比特。
- 数据链路层：在物理层提供比特流服务的基础上，建立相邻结点之间的数据链路，通过差错控制提供数据帧在信道上无差错的传输，并进行各电路上的动作系列。数据链路层在不可靠的物理介质上提供可靠的传输　　
- 网络层
- 传输层
- 会话层
- 表示层
- 应用层

|            | 功能                                                         | 网络设备                                                     | 协议      |
| ---------- | ------------------------------------------------------------ | ------------------------------------------------------------ | --------- |
| 应用层     | 直接向用户提供服务，完成用户希望在网络上完成的各种工作       |                                                              | HTTP, FTP |
| 表示层     | 处理用户信息的表示问题，如编码、数据格式转换和加密解密等     |                                                              | Telnet    |
| 会话层     | 组织和协调两个会话进程之间的通信 ，并对数据交换进行管理      |                                                              | DNS       |
| 传输层     | 向用户提供可靠的端到端的差错和流量控制，保证报文的正确传输，同时向高层屏蔽下层数据通信的细节，即向用户透明地传送报文。 |                                                              | TCP、UDP  |
| 网络层     | 在计算机网络中进行通信的两个计算机之间可能会经过很多个数据链路，也可能还要经过很多通信子网。网络层的任务就是选择合适的网间路由和交换结点， 确保数据及时传送 | 路由器、三层交换机                                           | IP、ARP   |
| 数据链路层 | 在物理层提供比特流服务的基础上，建立相邻结点之间的数据链路，通过差错控制提供数据帧在信道上无差错的传输，并进行各电路上的动作系列。数据链路层在不可靠的物理介质上提供可靠的传输 | 网桥（Linux虚拟网桥）、交换机)（二层交换机）、网卡（其实网卡是一半工作在物理层、一半工作在数据链路层） | PPP       |
| 物理层     | 主要定义物理设备标准，它的主要作用是传输比特流，这一层的数据叫做比特 | 中继器、集线器                                               | IEEE      |



## 2. 集线器、交换机、三层交换机、路由器

- 集线器：工作在osi第一层机物理层，传输的单位是比特，会以广播的形式传输
- (二层)交换机：具有MAC地址转发表，会指定端口进行传输
- 三层交换机：是利用MAC地址（物理地址）来确定转发数据的目的地址，主要用于局域网之间的连接
- 路由器：利用IP地址（网络地址）来确定数据转发的地址，主要是将多个局域网连接到广域网，除此之外，路由器还比三层交换机多防火墙等功能



## 3. 浏览器上输入地址后的整个请求过程

