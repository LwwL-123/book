# OS

## 1. 进程与线程的区别

在早期的操作系统中，只有进程，没有线程， 随着技术发展，在执行一些细小任务时，本身无需分配单独资源时，也只能创建进程来执行，但是进程切换开销很大，而且进程间通信共享数据也很麻烦，所以就提出了线程的概念。

一个进程独享一块虚拟内存，线程就是在进程的虚拟内存中分配一套独立的栈和寄存器，CPU操作的是线程的栈帧，所以线程是调度的基本单位，而共享进程的虚拟内存空间，所以进程是资源分配的基本单位。

在linux系统中，实际上没有线程的概念，只用了一个task_struct结构体，进程创建子进程时会指定他和自己使用同一套地址空间和句柄表的资源，用这种方法实现多线程的效果。而在windows系统中，进程对应一个PCB进程控制块，而线程使用TCB记录的



## 2.进程和线程间的通信方式

进程：

- 匿名管道，命名管道（见[进程与线程](http://47.116.70.98:8081/Linux/Linux%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B.html)，观看管道原理详解）
- 消息队列
- 共享内存
- 信号
- socket

线程：**因为同一进程的不同线程共享同一份全局内存区域，其中包括初始化数据段、未初始化数据段，以及堆内存段，所以线程之间可以方便、快速地共享信息。只需要将数据复制到共享（全局或堆）变量中即可。**不过，要避免出现多个线程试图同时修改同一份信息，通常使用：

- 互斥锁
- 信号量



## 3. 线程、协程的区别

先讲解一下虚拟内存分为内核空间和用户空间，所有的系统操作，都得由用户发起系统中断，转而在内核空间中完成。线程可以说是内核级线程，而协程则是由线程创建，操作系统无法调度，由线程自己调度，自己分配空间，但只能在用户空间中，不能涉及内核空间。



## 4. 常见的进程调度算法

先来先服务，短作业优先，高响应比优先，时间片轮转



## 5. 进程线程的状态

因为线程是CPU调度的基本单位，而在Linux系统中，其实没有线程和进程的概念的区分，所以他们的状态都是：

- 创建，就绪，运行，阻塞，结束
- 创建，就绪，就绪挂起，运行，阻塞，阻塞挂起，结束



## 6. 僵尸进程和孤儿进程

`僵尸进程`（Z僵死状态（zombie））：当一个子进程结束运行（一般是调用exit、运行时发生致命错误或收到终止信号所导致）时，子进程的退出状态（返回值）会回报给操作系统，系统则以SIGCHLD信号将子进程被结束的事件告知父进程，此时子进程的进程控制块（PCB）仍驻留在内存中。一般来说，收到SIGCHLD后，父进程会使用wait系统调用以获取子进程的退出状态，然后内核就可以从内存中释放已结束的子进程的PCB；而如若父进程没有这么做的话，子进程的PCB就会一直驻留在内存中，也即成为僵尸进程

其实，僵尸进程是有危害的。进程的退出状态必须被维持下去，因为它要告诉关心它的进程（父进程），你交给我的任务，我办的怎么样了。可父进程如果一直不读取，那子进程就一直处于Z状态。维护退出状态本身就是要用数据维护，也属于进程基本信息，所以保存在task_struct(PCB)中，换句话说，当一个进程一直处于Z状态，那么它的PCB也就一直都要被维护。因为PCB本身就是一个结构体会占用空间，僵尸进程也就会造成资源浪费，所以我们应该避免僵尸进程的产生

想要解决僵尸进程也很简单，直接找到父进程杀掉，那么僵尸进程将会被init进程接管，并回收

`孤儿进程`：孤儿进程则是指当一个父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程。孤儿进程将被init进程(进程号为1)所收养，并由init进程对它们完成状态收集工作。

孤儿进程由于有init进程循环的wait()回收资源，因此并没有什么危害



## 7. 管道的底层实现原理

创建管道会返回两个描述符，管道的读取端描述符 `fd[0]`，另一个是管道的写入端描述符 `fd[1]`

匿名管道是特殊的文件，只存在于内存，不存于文件系统中。也就是内核空间里面的一段缓存，通过父子进程共享文件描述符，来进行管道通信。

而对于命名管道，也就是创建了一个管道文件，只要在进程中读取这个文件，就可以达到通信的目的



## 8. 线程和进程的上下文切换

`同一个进程的线程上下文切换`: 只需要将线程的执行现场保存起来，就是栈帧，指令指针，寄存器等。再把

指令指针，栈指针这些寄存器的值修改为新线程的信息。

`不同进程的线程上下文切换`：如果是不同进程间的切换，就要涉及到进程的切换。首先CPU保存的页表需要切换到进程B，所以进程切换和线程切换的区别是，进程切换会导致地址空间等进程资源发生变化，还会导致TLB缓存失效，代价会更大。**进程的上下文切换不仅包含了虚拟内存、栈、全局变量等用户空间的资源，还包括了内核堆栈、寄存器等内核空间的资源**



## 9. 虚拟内存

可以从为什么会有虚拟内存，虚拟内存如何映射到物理内存，一级页表和二级页表的区别，二级页表为什么省空间，线性地址后12位多余字段的作用，虚拟内存的空间分配

详见： [虚拟内存](http://47.116.70.98:8081/Linux/Linux%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98.html)



## 10. 内存泄漏和内存溢出

- 内存溢出**（Out Of Memory）**：申请内存时，没有足够的空间

- 内存泄漏**（Memory Leak）**：申请了内存，但没有释放，导致空间浪费

  - 也就是向系统申请分配内存进行使用(new)，可是使用完了以后却不归还(delete)，结果你申请到的那块内存你自己也不能再访问（也许你把它的地址给弄丢了），而系统也不能再次将它分配给需要的程序。

  

也就是内存泄漏最终会导致内存溢出



## 11. 页面置换算法

当 CPU 访问的页面不在物理内存时，便会产生一个缺页中断，请求操作系统将所缺页调入到物理内存。

- 最佳页面置换算法（OPT）
  - **置换在「未来」最长时间不访问的页面**
- 先进先出置换算法（FIFO）
  - **选择在内存驻留时间很长的页面进行中置换**
- 最近最久未使用的置换算法（LRU）
  - **选择最长时间没有被访问的页面进行置换**
- 最不常用置换算法（LFU）
  - **选择「访问次数」最少的那个页面，并将其淘汰**



## 12. 用户态内核态切换

线程中发生函数调用就是在线程栈中分配函数调用栈，而虚拟内存分配，文件操作，网络读写等很多功能都是由操作系统来完成的，再向用户程序暴露接口。所以线程免不了要“系统调用”，CPU中会有一个特权标志，用于记录当前程序是执行在用户态还是内核态，只有标记为内核态才可以访问内核空间。如果线程处于用户态，就不能访问内核空间，所以系统调用发生时，就得切换到内核态，使用线程的内核栈，执行内核空间的系统函数

最初系统调用是通过软中断触发的，就是通过指令模拟中断。在OS中，会有一张中断向量表，用来吧各个中断编号映射到相应的处理程序，例如在linux系统中，系统调用中断对应的编号为0x80，对应的系统程序，就是用来派发系统调用的。在硬件层面，CPU有一个中断控制器，负责接收中断信号，切换到内核态，保存用户态执行现场。一部分寄存器的值会通过硬件保存起来，还有一部分通用寄存器的值，会被压入内核栈中。等系统调用结束后，再利用之前保存的信息，恢复线程在用户态的执行现场，继续执行后面的指令，即完成的一次系统调用。

后改为特殊指令触发系统调用，如sysenter，syscall，当cpu执行到这些指令时，就会陷入内核态，从专用的寄存器拿到派发入口的地址，省去了查询中断向量表的过程。



## 13. 软中断和硬中断

- 软中断是执行中断指令产生的，而硬中断是由外设引发的。
- 硬中断的中断号是由中断控制器提供的，软中断的中断号由指令直接指出，无需使用中断控制器。
- 硬中断是可屏蔽的，软中断不可屏蔽。

为了避免由于中断处理程序执行时间过长，而影响正常进程的调度，Linux 将中断处理程序分为上半部和下半部：

- 上半部，对应硬中断，由硬件触发中断，用来快速处理中断；
- 下半部，对应软中断，由内核触发中断，用来异步处理上半部未完成的工作；

软终端有：网络收发、定时、调度、RCU 锁等各种类型,可以通过查看 /proc/softirqs 来观察软中断的累计中断次数情况



# Mysql

## 1. B- 树与 B+ 树的区别

- #### 单点查询

B+ 树只有叶子节点才会存放数据，B树所有节点都存放数据，所以B-树在最好的情况下可能达到O(1)，但波动较大。B+树的非叶子节点可以存放更多的索引，因此 B+ 树可以比 B 树更「矮胖」，查询底层节点的磁盘 I/O次数会更少

- #### 插入和删除效率

B+ 树有大量的冗余节点，这样使得删除一个节点的时候，可以直接从叶子节点中删除，甚至可以不动非叶子节点，这样删除非常快。B 树则不同，B 树没有冗余节点，删除节点的时候非常复杂，比如删除根节点中的数据，可能涉及复杂的树的变形。

- #### 范围查询

B+ 树所有叶子节点间还有一个链表进行连接，这种设计对范围查找非常有帮助。B 树没有将所有叶子节点用链表串联起来的结构，因此只能通过树的遍历来完成范围查询，这会涉及多个节点的磁盘 I/O 操作，范围查询效率不如 B+ 树



## 2. 为什么用B+树，不用二叉树、B树和红黑树

要设计一个 MySQL 的索引数据结构，不仅仅考虑数据结构增删改的时间复杂度，更重要的是要考虑磁盘 I/0 的操作次数。因为索引和记录都是存放在硬盘，硬盘是一个非常慢的存储设备，我们在查询数据的时候，最好能在尽可能少的磁盘 I/0 的操作次数内完成。

# 网络/基础

## 1. **OSI七层、五层模型，每一层的作用**

OSI七层模型：

- 物理层：主要定义物理设备标准，它的主要作用是传输比特流，这一层的数据叫做比特。
- 数据链路层：在物理层提供比特流服务的基础上，建立相邻结点之间的数据链路，通过差错控制提供数据帧在信道上无差错的传输，并进行各电路上的动作系列。数据链路层在不可靠的物理介质上提供可靠的传输　　
- 网络层
- 传输层
- 会话层
- 表示层
- 应用层

|            | 功能                                                         | 网络设备                                                     | 协议      |
| ---------- | ------------------------------------------------------------ | ------------------------------------------------------------ | --------- |
| 应用层     | 直接向用户提供服务，完成用户希望在网络上完成的各种工作       |                                                              | HTTP, FTP |
| 表示层     | 处理用户信息的表示问题，如编码、数据格式转换和加密解密等     |                                                              | Telnet    |
| 会话层     | 组织和协调两个会话进程之间的通信 ，并对数据交换进行管理      |                                                              | DNS       |
| 传输层     | 向用户提供可靠的端到端的差错和流量控制，保证报文的正确传输，同时向高层屏蔽下层数据通信的细节，即向用户透明地传送报文。 |                                                              | TCP、UDP  |
| 网络层     | 在计算机网络中进行通信的两个计算机之间可能会经过很多个数据链路，也可能还要经过很多通信子网。网络层的任务就是选择合适的网间路由和交换结点， 确保数据及时传送 | 路由器、三层交换机                                           | IP、ARP   |
| 数据链路层 | 在物理层提供比特流服务的基础上，建立相邻结点之间的数据链路，通过差错控制提供数据帧在信道上无差错的传输，并进行各电路上的动作系列。数据链路层在不可靠的物理介质上提供可靠的传输 | 网桥（Linux虚拟网桥）、交换机)（二层交换机）、网卡（其实网卡是一半工作在物理层、一半工作在数据链路层） | PPP       |
| 物理层     | 主要定义物理设备标准，它的主要作用是传输比特流，这一层的数据叫做比特 | 中继器、集线器                                               | IEEE      |



## 2. 集线器、交换机、三层交换机、路由器

- 集线器：工作在osi第一层机物理层，传输的单位是比特，会以广播的形式传输
- (二层)交换机：具有MAC地址转发表，会指定端口进行传输
- 三层交换机：是利用MAC地址（物理地址）来确定转发数据的目的地址，主要用于局域网之间的连接
- 路由器：利用IP地址（网络地址）来确定数据转发的地址，主要是将多个局域网连接到广域网，除此之外，路由器还比三层交换机多防火墙等功能



## 3. 浏览器上输入地址后的整个请求过程

